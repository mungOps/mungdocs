[{"id":0,"href":"/devops/docs/Docker/Docker/Docker00/","title":"0. Docker\u0026 Container","section":"Docker","content":"\rDocker 와 Container\r#\rDocker의 등장배경\r#\rDocker는 2013년에 dotCloud의 의해 2013년 PyCon에서 (The future of Linux Containers) 처음 데모 되었다.\n이는 오클랜드 항구에 들어오는 모든 컨테이너 선박을 보며, 한 서버에서다른 서버로 앱을 옮기는 것 보다, 지구 반대편으로 컨테이너를 옮기는 것이 더 쉽다라는 취지에서 개발됨.\n위 문제는 기존 가상화기술을 사용하면 가능했으나, 리소스의 수가 커지고 대규모의 관리가 증대됨에 따라 필요성이 대두되어짐.\ndotCloud 팀은 가상화 자체가 문제가 아니라 가상화 사용 방식이 문제라는 것을 인식했으며, 전체 운영 체제를 가상화하는 대신 애플리케이션과 해당 종속성만 가상화하는 것이 더 효율적이라 생각해었고, 이 것이 Container 의 개념으로 개발됨.\nContainer란?\r#\r기본 운영 체제(OS) 커널을 동일한 시스템의 다른 컨테이너와 공유하는 격리된 환경에서 애플리케이션을 실행하는 방법\nContainer의 격리된 환경의 특징\nVM이 완전한 운영체제와 에뮬리이션을 갖는 반면, 컨테이너는 호스트 시스템과 커널을 공유 위와 같은 특성으로 VM의 비해 사용되는 리소스가 적어, 가볍고 빠르게 실행이 가능 컨테이너는 완전 격리된 상태이기에, 실행 환경이 동일하면 어떠한 방식으로도 실행이 가능 즉, 컨테이너 기반 가상화는 기존 가상화와 달리 하이퍼바이저 위에서 여러 개의 Guest OS를 실행하는 대신 호스트 OS 커널을 사용하여 격리된 여러 개의 컨테이너를 실행\nContainer 기반 기술\r#\rChroot and Chroot Jail\r#\rChroot(Change Root)는 프로세스의 Root 디렉토리를 변경하여 파일 시스템에서 특정 파일 및 디렉터리 인덱스를 좁힐 수 있는 기능\nJail은 chroot에서 더 진보된 단계로, 기존 Chroot 설정이여도 프로세스가 네트워크 통신 등의 역할을 수행할 수 있었지만, Jail은 이를 제한 할 수 있었음.\n이어 서로 다른 프로세스 그룹 간의 경계 관리 솔루션인 Solaris Zones이 출시되며, Container 라는 용어가 활용되기 시작하였음.\nLXC (LinuX Container)\r#\rLXC란 리눅스 컨테이너로 해당 커널의 주 구성요소는 namespace, cgroups, chroot 이다. cgroup (control group)\r#\rcgroup을 사용하여 각 컨테이너에 대한 시스템 리소스(CPU, 메모리, 디스크 I/O)를 제한하고 우선순위를 지정하며, 각 컨테이너에 리소스를 제어되고 효율적인 방식으로 할당하여 컨테이너의 성능에 영향을 미치는 것을 방지하는 역할을 수행한다. namespace\r#\rLXC는 Linux 커널 namespace를 사용하여 각 컨테이너에 대해 별도의 네임스페이스를 생성 namespace는 프로세스 ID, 네트워크 인터페이스, 파일 시스템 등 각 컨테이너에 대한 다양한 시스템 리소스를 격리하여, 다른 컨테이너 리소스의 간섭을 막는 역할을 수행한다. chroot\r#\r위에서 나타냈듯이, 각 컨테이너는 고유한 파일 시스템 계층 구조를 가질 수 있으며, 한 컨테이너 내의 프로세스가 다른 컨테이너의 파일에 액세스 하거나 수정 불가능하게 함 위 LXC 커널들을 사용하여 컨테이너 서비스가 개발되었기 때문에, 다른 운영체제서는 사용이 불가능 Namespaces: 네임스페이스는 리눅스에서 프로세스를 격리하고 독립적인 환경을 제공하는 기술로, 여러 가지 네임스페이스를 활용하여 프로세스, 마운트 포인트, 네트워크, 호스트 이름 등을 격리\nCgroups (컨트롤 그룹): 리눅스에서 프로세스 그룹을 생성하고 리소스를 할당하거나 제한하는 기술 Cgroups를 사용하여 CPU, 메모리, 디스크 I/O 등의 자원을 제어하고 할당\nAppArmor 및 SELinux Profiles: AppArmor와 SELinux는 각각 리눅스 시스템에서 프로세스의 접근 권한을 제한하는 보안 모듈로 프로파일을 사용하여 각 컨테이너의 권한을 제어하고 보안을 강화\nNetwork Devices (네트워크 디바이스): 네트워크를 격리하고 각 컨테이너에 독립적인 네트워크 환경을 제공 및 네트워크 디바이스를 사용하여 컨테이너 간 통신이나 호스트와의 통신을 관리\nChroot (체인지 루트): 파일 시스템에서 특정 디렉토리를 컨테이너의 루트로 변경, 이를 통해 컨테이너는 호스트 시스템과 독립된 파일 시스템 환경을 구축이 가능\nSeccomp Policies: Seccomp은 리눅스에서 프로세스가 사용할 수 있는 시스템 콜을 제한하는 커널 보안 모듈로 Seccomp를 사용하여 컨테이너에서 특정 시스템 콜을 차단하여 보안을 강화\nDocker의 등장\r#\rLXC는 사용자 공간 수준에서 깔끔하고 강력한 인터페이스를 제공하지만 여전히 사용하기 쉽지 않고 대중적 매력을 불러일으키지도 못했고, Docker 커널 기능을 다루는 복잡성의 대부분을 추상화하면서 애플리케이션과 그 종속성을 컨테이너에 묶는 간단한 형식을 제공하여 이를 해결하였다.\n단, Docker는 초기 LXC에서 실행환경을 구성하였으나, 이후 Go Lang을 활용한 libcontainer로 내부 환경을 변경하여 LXC와 같은 외부 패키지에 의존적이지 않도록 개발을 진행하였다.\nDocker의 이해\r#\r도커는 위 그림과 같이 모듈식 아키텍처를 가지고 있으며, 서비스를 제공하기 위해 몇 가지 주요 구성 요소를 사용 Dockerd: docker engine으로 불리며 API 요청을 수신하고 개체를 관리하는 데몬 프로세스\nContainerd: Docker 객체를 관리하기 위해 이미지 다운로드 및 컨테이너 실행과 같은 작업을 수행\nrunc: 커널 기능과 상호작용하며 네임스페이스 및 제어 그룹을 생성하는 표준 메커니즘을 제공\nDocker Image의 이해\r#\r도커의 이미지는 컨테이너를 인스턴스화 하는 데 사용하는 읽기 전용 레이어 파일이다.\n이미지는 Dockerfile를 통해 생성하며, Dockerfile의 각 명령은 상위 이미지 위에 레이어를 생성하여 적용시키는 개념이다.\nDocker Storage\r#\rDocker Image로 생성된 컨테이너는 위와 같이 Layer 형식으로 구성 되며, 이는 위 그림과 같이 스토리지 드라이버에 저장된다.\n스토리지 드라이버는 이미지 레이어와 컨테이너 레이어의 콘텐츠를 관리하며, aufs, overlay, overlay2, btrfs, ztf 등의 여러 스토리지 드라이버를 사용 할 수 있다.\n각 스토리지 드라이버는 구현 방식이 다르지만 모두 스택 가능한 이미지 레이어와 CoW(Copy On Write 기록 중 복사) 전략을 사용 (CoW는 기본적으로 효율성을 극대화하기 위해 파일을 공유하고 복사하는 전략)\n종류 특징 Volume 볼륨은 호스트 파일 시스템의 특별한 디렉토리나 Docker가 관리하는 볼륨 드라이버에 의해 생성되며, 컨테이너에 마운트되며, 볼륨은 컨테이너의 생명주기 동안 데이터를 유지하고, 여러 컨테이너 간에 데이터를 쉽게 공유하는 역할을 수행 Bind Mount 바인드 마운트는 호스트 머신의 파일 시스템 경로를 직접 컨테이너 경로에 마운트하는 방식 Tmpfs 컨테이너 내의 임시 파일 시스템으로, RAM을 기반으로 컨테이너의 실행 중에만 유지되며, 컨테이너가 종료되면 데이터가 손실 Docker Networking\r#\rDocker 컨테이너는 다른 워크로드 유형에 대한 명시적인 지식 없이도 서로 연결될 수 있으며, Docker가 아닌 워크로드와도 연결이 가능한데, 이는 완전히 연결 가능한 Docker의 네트워킹 하위 시스템 덕분에 가능 이는 아래의 네트워크 드라이버를 통해 지원 종류 특징 bridge 브리지 드라이버를 사용하여 독립형 컨테이너에서 실행되는 애플리케이션 간에 통신 (기본 드라이버) host 호스트 드라이버는 컨테이너와 호스트 사이의 네트워크 격리를 제거하고 호스트 네트워크를 직접 사용 overlay 오버레이 드라이버를 사용하여 여러 Docker 데몬을 함께 연결 (Docker Swarm) macvlan macvlan 드라이버를 사용하면 Docker 데몬이 MAC 주소를 통해 컨테이너로 트래픽을 라우팅할 수 있도록 MAC 주소를 컨테이너에 할당이 가능 none 네트워크 비활성화 Docker bridge network\r#\rDocker는 기본적으로 브리지 네트워크 \u0026ldquo;docker0\u0026quot;을 생성하고 \u0026ldquo;vethxx\u0026quot;를 통해 모든 컨테이너 네트워크를 여기에 연결\n기본 브리지 네트워크에 연결된 컨테이너는 IP 주소를 통해 서로 통신할 수 있습니다 . 또한 브리지 네트워크 “docker0”은 호스트 네트워크 “eth0”에 연결되어 외부 네트워크에 대한 연결을 제공\n참조\r#\r"},{"id":1,"href":"/devops/docs/CICD/CICD/git00/","title":"0. Git이란?","section":"CI/CD 배포 입문","content":"\rGIT\r#\rGit이란?\r#\r깃(Git)은 2005년에 리누스 토르발스에 의해 개발된 분산 버전관리 시스템(Distributed Version Control Systems - DVCS)\n컴퓨터 파일의 변경사항을 추적하고 여러명의 사용자들 간에 파일에 대한 작업을 조율하는데 사용하는 형상관리 도구 이다.\nDVCS에서의 클라이언트는 단순히 파일의 마지막 스냅샷을 Checkout 하지 않고, 저장소를 히스토리와 더불어 전부 복제하여, 서버에 문제가 생기더라도 바로 복구가 가능하다.\nGIT과 SVN의 차이\r#\r단, Git은 기존 SVN(Subversion SVN)와 기능면에서는 유사해 보일 수는 있으나, 아래와 같은 차이를 가지고 있다.\n기능 SVN GIT 파일관리 중앙서버 업로드 로컬저장소 저장 후, 중앙서버 업로드 형상관리 동시 업로드 시 충돌가능 Branch, Merge로 충돌가능성이 낮음 작업관리 모든 작업이 서버에서 진행 작업은 로컬에서 진행 후, 업로드만 서버에 진행 형상관리 히스토리 관리 기능이 부족 히스토리 관리가 용이하게 구현되어있음 즉, Git과 SVN의 가장 큰 차이는 SVN은 서버단에서 작업을 수행하지만, GIT 로컬에서 자기만의 레포지터리를 생성 및, 분기를 이용한 효율적인 형상관리가 가능하다.\n대부분의 버전관리는 시간순으로 진행되나, GIT은 Branch를 통해 관리한다.\nGit은 대부분의 명령을 local에서 진행하기 때문에, 네트워크 등의 영향을 받지 않고, 무결성을 유지함에 보다 용이하다.\n#\rGIT Status\r#\rGit의 상태에는 크게 3가지가 있다. Committed란 데이터가 로컬 데이터베이스에 안전하게 저장됐다는 것을 의미 Modified는 수정한 파일을 아직 로컬 데이터베이스에 커밋하지 않은 상태 Staged란 현재 수정한 파일을 곧 커밋할 것이라고 표시한 상태 위는 Git의 워킹 트리를 나타내며, Git 디렉토리는 Git이 프로젝트의 메타데이터와 객체 데이터베이스를 저장하는 곳을 의미한다.\n워킹트리는 프로젝트의 특정 버전을 Checkout한 것이며, Git 디렉토리는 현재 작업하는 디스크에 존재하고, 디렉토리 안에 압축된 데이터베이스에서 파일을 가져와 워킹 트리를 생성한다.\nGit에서 Staging Area는 Index라고도 하며, Staging Area는 단순한 파일로, commit할 파일들에 대한 정보를 저장한다.\n즉, Git의 기본적으로 Git의 구동동작은 아래와 같다.\n워킹트리에서 파일을 수정 Staging Area에 파일을 Stage 해서 commit할 스냅샷을 만든다. 여기서 추가, 수정, 삭제 등의 작업이 가능하다. Staging Area에 있는 파일들을 commit해서 Git 디렉토리에 영구적인 스냅샷을 저장한다. 결과적으로 Git 디렉토리에 있는 파일들은 Committed 된 상태이며, 파일을 수정하고 Staging Area에 추가했다면 Staged 된 상태라고 할 수 있다.\n여기서 Checkout 후, 수정했지만 Staging Area에 추가되지 않았다면 Modified된 상태이다.\nGit 설정\r#\rGit 최초 설정\r#\rGit을 설치하고 나면 Git의 사용 환경을 적합하게 설정해주어야 한다.\n이는 git config 라는 도구와 설정으로 내용을 확인하고 변경할 수 있다.\n/etc/gitconfig : 시스템의 모든 사용자와 모든 저장소에 적용되는 설정 ( git config \u0026ndash;system ) ~/.gitconfig, ~/.config/git/config : 특정 사용자에게만 적용되는 설정 ( git config \u0026ndash;global ) .git/config : 현재 디렉토리에만 적용되어 있는 설정 ( git config \u0026ndash;local ) 위 설정들은 역순으로 우선시 되어 1 \u0026lt; 2 \u0026lt; 3 과 같은 우선순위를 가지고 있다.\n$ git config --global user.name \u0026#34;John Doe\u0026#34;\r$ git config --global user.email johndoe@example.com \u0026ndash;global 옵션으로 설정하는 것은 한번이며 (전역), 만약 프로젝트마다 다른 이름과 메일주소를 사용하고 싶다면 \u0026ndash;global 옵션을 빼고 사용한다. #\r$ git config --list\ruser.name=John Doe\ruser.email=johndoe@example.com\rcolor.status=auto\rcolor.branch=auto\rcolor.interactive=auto\rcolor.diff=auto\r$ git config user.name\rjohn Doe 설정했던 옵션들은 git config \u0026ndash;list 명령어로 확인할 수 있다. #\rGit의 기초\r#\r$ cd $ git init 위 명령어를 통해 .git이라는 하위 디렉터리를 만들며, 이 안에는 저장소에 필요한 뼈대 파일(Skeleton)이 들어 있다. #\r$ git add *.c\r$ git add LICENSE\r$ git commit -m \u0026#39;initial project version\u0026#39; 위 명령어를 통해 GIt 저장소가 생성되었고 파일 버전 관리가 시작되었다. (commit) #\r$ git clone https://github.com/libgit2/libgit2\r$ git clone https://github.com/libgit2/libgit2 \u0026lt;other name\u0026gt; 다른 프로젝트의 참여하고 싶거나, git 저장소를 복사하고 싶을 때, git clone 명령어를 사용한다. Subversion과 같은 VCS에 익숙한 사용자에게는 \u0026ldquo;Checkout\u0026rdquo; 이 아닌, \u0026ldquo;clone\u0026rdquo; 이라는 점이 다르며, git은 서버에 있는 거의 모든 데이터를 복사한다. 즉, git은 서버의 모든 데이터 및 프로젝트의 히스토리를 전부 받아와, 실제 서버의 디스크가 망가져도, 로컬에서 복구가 가능한 특징을 가진다. (단, 서버설정파일은 제외) #\r이제 git 저장소를 만들고(init) 워킹 디렉토리에 Checkout(commit)도 헀다면, 이제는 파일의 스냅샷을 커밋한다. 워킹 디렉토리의 파일은 크게 Tracked(관리대상)과 Untracked(비관리대상)으로 나뉘며, Tracked 파일은 이미 스냅샷에 포함돼 있던 파일(레포지터리에 있던)이다. Tracked 파일은 다시 Unmodified(비수정)와 Modified(수정된), 그리고 Staged(commit으로 저장소에 기록될) 상태로 나뉘어진다. 이 외의 나머지는 untracked파일이며, 이는 워킹 디렉토리에 있는 파일 중 StagingArea에 포함되지 않는 파일이다. 처음 clone을 진행하면, 모든 파일은 Tracked(스냅샷에 포함)파일이지만, Unmodified(수정되지 않았기에)상태이다. 만약 clone 진행 후, 어떤 파일을 수정하게 되면 unmodified -\u0026gt; modified 상태로 상태가 변경되며 실제로 commit을 진행하기 위한 staged 상태를 만들고, staged 상태의 파일을 commit하게 되며, git은 이러한 lifecycle을 반복하게 된다. #\r$ git status\rOn branch master\rYour branch is up-to-date with \u0026#39;origin/master\u0026#39;.\rnothing to commit, working directory clean 위 명령어를 실행하면 현재 하나도 수정되지 않았음을 알려준다. $ echo \u0026#39;My Project\u0026#39; \u0026gt; README\r$ git status\rOn branch master\rYour branch is up-to-date with \u0026#39;origin/master\u0026#39;.\rUntracked files:\r(use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed)\rREADME\rnothing added to commit but untracked files present (use \u0026#34;git add\u0026#34; to\rtrack) README 파일은 “Untracked”에 속해 있는데 이것은 README 파일이 Untracked 상태라는 것을 의미한다. Git은 Untracked 파일을 아직 스냅샷(커밋)에 넣어지지 않은 파일이라고 본다. git init 명령을 실행한 후, git add (files) 명령을 실행했던 걸 기억할 것이다. 이 명령을 통해 디렉토리에 있는 파일을 추적하고 관리하도록 한다. git add 명령은 파일 또는 디렉토리의 경로를 아규먼트로 받는다. #\r$ git add README\r$ git status\rOn branch master\rYour branch is up-to-date with \u0026#39;origin/master\u0026#39;.\rChanges to be committed:\r(use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage)\rnew file: README\rChanges not staged for commit:\r(use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed)\r(use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in workingdirectory)\rmodified: CONTRIBUTING.md git status 명령을 실행하면 README 파일이 Tracked 상태이면서 commit에 추가될 Staged 상태라는 것이 확인이 가능하다. \u0026ldquo;Changes to be commiteed\u0026rdquo; 에 들어 있는 파일은 Staged 상태라는 것을 의미한다. 즉, commit을 실행하면 add를 실행한 시점의 파일이 commit되어 stage -\u0026gt; git history에 남게된다. CONTRIBUTING.md은 \u0026ldquo;Changes not staged for commit\u0026quot;에 있으며, 이는 수정한 파일이 Tracked 상태이지만 아직 Staged 상태는 아니라는 것이며 이는 add 명령어를 통해 staged에 올릴 수 있음을 의미한다. #\r$ git add CONTRIBUTING.md\r$ git status\rOn branch master\rYour branch is up-to-date with \u0026#39;origin/master\u0026#39;.\rChanges to be committed:\r(use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage)\rnew file: README\rmodified: CONTRIBUTING.md add 후 다시 staus를 입력하면 staged 상태로 올라간 것을 확인할 수 있다. #\r$ git status -s\rM README\rMM Rakefile\rA lib/git.rb\rM lib/simplegit.rb\r?? LICENSE.txt #\r이는 위처럼 status -s 옵션을 통해 간단하게 확인할 수 있으며 앞에 문자는 아래와 같은 의미를 가진다. A : New file M : Modified file MM : 작업 디렉터리 및 스테이지 변경 ?? : Untracked Unmodified 파일을 출력되지 않음 #\r파일무시하기\r#\r$ cat .gitignore\r*.[oa]\r*~ .gitignore 파일을 만들고 그 안에 무시할 패턴을 적으면, 해당 패턴과 일치하는 파일들은 commit 되지 않는다. .gitignore은 아래와 같은 특징을 가진다. 아무것도 없는 라인이나, #로 시작하는 라인은 무시한다. 표준 Glob 패턴을 사용한다. 이는 프로젝트 전체에 적용된다. 슬래시(/)로 시작하면 하위 디렉토리에 적용되지(Recursivity) 않는다. 디렉토리는 슬래시(/)를 끝에 사용하는 것으로 표현한다. 느낌표(!)로 시작하는 패턴의 파일은 무시하지 않는다 기타 예제는 (gitignore_repo)[https://github.com/github/gitignore]를 참조하자. #\r변경사항 확인하기\r#\r$ git diff\r$ git diff --staged git status 명령은 특정파일의 Staged 상태인지는 확인할 수 있으나, 변경사항은 확인할 수 없다. git diff 명령을 사용하는데 Patch처럼 어떤 라인을 추가했고 삭제했는지가 궁금할 때 사용한다. #\r$ git log\rcommit ca82a6dff817ec66f44342007202690a93763949\rAuthor: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt;\rDate: Mon Mar 17 21:52:11 2008 -0700\rchanged the version number\rcommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\rAuthor: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt;\rDate: Sat Mar 15 16:40:33 2008 -0700\rremoved unnecessary test\rcommit a11bef06a3f659402fe7563abf99ad00de2209e6\rAuthor: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt;\rDate: Sat Mar 15 10:31:28 2008 -0700\rfirst commit\r$ git log -p -2\rcommit ca82a6dff817ec66f44342007202690a93763949\rAuthor: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt;\rDate: Mon Mar 17 21:52:11 2008 -0700\rchanged the version number\rdiff --git a/Rakefile b/Rakefile\r...\r$ git log --stat\rcommit ca82a6dff817ec66f44342007202690a93763949\rAuthor: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt;\rDate: Mon Mar 17 21:52:11 2008 -0700\rchanged the version number\rRakefile | 2 +-\r1 file changed, 1 insertion(+), 1 deletion(-)\rcommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\r... git log 명령을 실행하면 저장소의 커밋 히스토리를 시간순으로 보여준다. 즉, 가장 최근의 커밋이 가장 먼저 나온다. 그리고 이어서 각 커밋의 SHA-1 체크섬, 저자 이름, 저자 이메일, 커밋한 날짜, 커밋 메시지를 보여준다. -p, \u0026ndash;patch 는 굉장히 유용한 옵션이다. -p 는 각 커밋의 diff 결과를 보여준다. \u0026ndash;stat 옵션으로 각 커밋의 통계 정보를 출력할 수 있다. \u0026ndash;pretty 옵션이다. 이 옵션을 통해 히스토리 내용을 보여줄 때 기본 형식 이외에 여러 가지 중에 하나를 선택할 수 있다. #\r회귀\r#\r#\r$ git commit -m \u0026#39;initial commit\u0026#39;\r$ git add forgotten_file\r$ git commit --amend 위는 실수로 파일을 Stage 하는 것을 깜빡하고 빠트린 파일이 있으면 위와 같이 고칠 수 있다. 하지만, 이는 두 번째 commit이 첫 번째 commit이 완전히 뒤집어 쓰는 것(첫 번째 commit은 히스토리가 없어진다)으로 주의가 필요하다. #\r$ git reset HEAD CONTRIBUTING.md\rUnstaged changes after reset:\rM CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage)\rrenamed: README.md -\u0026gt; README\rChanges not staged for commit:\r(use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed)\r(use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r$ git status\rChanges not staged for commit:\r(use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed)\r(use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r$ git checkout -- CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage)\rrenamed: README.md -\u0026gt; README reset과 staged는 비슷하게 보일 수 있으나, 서로 사용되는 영역이 다른다. reset은 staged영역을 조절하는 데 사용되며, checkout은 주로 브런치 간 이동이나 특정 파일의 변경 내용을 취소하는 데 사용된다. #\r리모트 저장소\r#\r#\r$ git remote -v\rorigin https://github.com/schacon/ticgit (fetch)\rorigin https://github.com/schacon/ticgit (push) remote는 연결되어 있는 저장소를 의미하며, 이는 단지 네트워크 뿐이 아닌 다른 저장소도 의미함을 인지한다. 위 명령어를 통해 현재 연결되어 있는 저장소를 출력할 수 있다. #\r$ git remote\rorigin\r$ git remote add pb https://github.com/paulboone/ticgit\r$ git remote -v\rorigin https://github.com/schacon/ticgit (fetch)\rorigin https://github.com/schacon/ticgit (push)\rpb https://github.com/paulboone/ticgit (fetch)\rpb https://github.com/paulboone/ticgit (push) git remote add \u0026lt;단축이름\u0026gt; 으로 원격 저장소를 연격할 수 있다. "},{"id":2,"href":"/devops/docs/Git/Git/git00/","title":"0. Git이란?","section":"Git","content":"\rGIT\r#\rGit이란?\r#\r깃(Git)은 2005년에 리누스 토르발스에 의해 개발된 분산 버전관리 시스템(Distributed Version Control Systems - DVCS)\n컴퓨터 파일의 변경사항을 추적하고 여러명의 사용자들 간에 파일에 대한 작업을 조율하는데 사용하는 형상관리 도구 이다.\nDVCS에서의 클라이언트는 단순히 파일의 마지막 스냅샷을 Checkout 하지 않고, 저장소를 히스토리와 더불어 전부 복제하여, 서버에 문제가 생기더라도 바로 복구가 가능하다.\nGIT과 SVN의 차이\r#\r단, Git은 기존 SVN(Subversion SVN)와 기능면에서는 유사해 보일 수는 있으나, 아래와 같은 차이를 가지고 있다.\n기능 SVN GIT 파일관리 중앙서버 업로드 로컬저장소 저장 후, 중앙서버 업로드 형상관리 동시 업로드 시 충돌가능 Branch, Merge로 충돌가능성이 낮음 작업관리 모든 작업이 서버에서 진행 작업은 로컬에서 진행 후, 업로드만 서버에 진행 형상관리 히스토리 관리 기능이 부족 히스토리 관리가 용이하게 구현되어있음 즉, Git과 SVN의 가장 큰 차이는 SVN은 서버단에서 작업을 수행하지만, GIT 로컬에서 자기만의 레포지터리를 생성 및, 분기를 이용한 효율적인 형상관리가 가능하다.\n대부분의 버전관리는 시간순으로 진행되나, GIT은 Branch를 통해 관리한다.\nGit은 대부분의 명령을 local에서 진행하기 때문에, 네트워크 등의 영향을 받지 않고, 무결성을 유지함에 보다 용이하다.\n#\rGIT Status\r#\rGit의 상태에는 크게 3가지가 있다. Committed란 데이터가 로컬 데이터베이스에 안전하게 저장됐다는 것을 의미 Modified는 수정한 파일을 아직 로컬 데이터베이스에 커밋하지 않은 상태 Staged란 현재 수정한 파일을 곧 커밋할 것이라고 표시한 상태 위는 Git의 워킹 트리를 나타내며, Git 디렉토리는 Git이 프로젝트의 메타데이터와 객체 데이터베이스를 저장하는 곳을 의미한다.\n워킹트리는 프로젝트의 특정 버전을 Checkout한 것이며, Git 디렉토리는 현재 작업하는 디스크에 존재하고, 디렉토리 안에 압축된 데이터베이스에서 파일을 가져와 워킹 트리를 생성한다.\nGit에서 Staging Area는 Index라고도 하며, Staging Area는 단순한 파일로, commit할 파일들에 대한 정보를 저장한다.\n즉, Git의 기본적으로 Git의 구동동작은 아래와 같다.\n워킹트리에서 파일을 수정 Staging Area에 파일을 Stage 해서 commit할 스냅샷을 만든다. 여기서 추가, 수정, 삭제 등의 작업이 가능하다. Staging Area에 있는 파일들을 commit해서 Git 디렉토리에 영구적인 스냅샷을 저장한다. 결과적으로 Git 디렉토리에 있는 파일들은 Committed 된 상태이며, 파일을 수정하고 Staging Area에 추가했다면 Staged 된 상태라고 할 수 있다.\n여기서 Checkout 후, 수정했지만 Staging Area에 추가되지 않았다면 Modified된 상태이다.\nGit 설정\r#\rGit 최초 설정\r#\rGit을 설치하고 나면 Git의 사용 환경을 적합하게 설정해주어야 한다.\n이는 git config 라는 도구와 설정으로 내용을 확인하고 변경할 수 있다.\n/etc/gitconfig : 시스템의 모든 사용자와 모든 저장소에 적용되는 설정 ( git config \u0026ndash;system ) ~/.gitconfig, ~/.config/git/config : 특정 사용자에게만 적용되는 설정 ( git config \u0026ndash;global ) .git/config : 현재 디렉토리에만 적용되어 있는 설정 ( git config \u0026ndash;local ) 위 설정들은 역순으로 우선시 되어 1 \u0026lt; 2 \u0026lt; 3 과 같은 우선순위를 가지고 있다.\n$ git config --global user.name \u0026#34;John Doe\u0026#34;\r$ git config --global user.email johndoe@example.com \u0026ndash;global 옵션으로 설정하는 것은 한번이며 (전역), 만약 프로젝트마다 다른 이름과 메일주소를 사용하고 싶다면 \u0026ndash;global 옵션을 빼고 사용한다. #\r$ git config --list\ruser.name=John Doe\ruser.email=johndoe@example.com\rcolor.status=auto\rcolor.branch=auto\rcolor.interactive=auto\rcolor.diff=auto\r$ git config user.name\rjohn Doe 설정했던 옵션들은 git config \u0026ndash;list 명령어로 확인할 수 있다. #\rGit의 기초\r#\r$ cd $ git init 위 명령어를 통해 .git이라는 하위 디렉터리를 만들며, 이 안에는 저장소에 필요한 뼈대 파일(Skeleton)이 들어 있다. #\r$ git add *.c\r$ git add LICENSE\r$ git commit -m \u0026#39;initial project version\u0026#39; 위 명령어를 통해 GIt 저장소가 생성되었고 파일 버전 관리가 시작되었다. (commit) #\r$ git clone https://github.com/libgit2/libgit2\r$ git clone https://github.com/libgit2/libgit2 \u0026lt;other name\u0026gt; 다른 프로젝트의 참여하고 싶거나, git 저장소를 복사하고 싶을 때, git clone 명령어를 사용한다. Subversion과 같은 VCS에 익숙한 사용자에게는 \u0026ldquo;Checkout\u0026rdquo; 이 아닌, \u0026ldquo;clone\u0026rdquo; 이라는 점이 다르며, git은 서버에 있는 거의 모든 데이터를 복사한다. 즉, git은 서버의 모든 데이터 및 프로젝트의 히스토리를 전부 받아와, 실제 서버의 디스크가 망가져도, 로컬에서 복구가 가능한 특징을 가진다. (단, 서버설정파일은 제외) #\r이제 git 저장소를 만들고(init) 워킹 디렉토리에 Checkout(commit)도 헀다면, 이제는 파일의 스냅샷을 커밋한다. 워킹 디렉토리의 파일은 크게 Tracked(관리대상)과 Untracked(비관리대상)으로 나뉘며, Tracked 파일은 이미 스냅샷에 포함돼 있던 파일(레포지터리에 있던)이다. Tracked 파일은 다시 Unmodified(비수정)와 Modified(수정된), 그리고 Staged(commit으로 저장소에 기록될) 상태로 나뉘어진다. 이 외의 나머지는 untracked파일이며, 이는 워킹 디렉토리에 있는 파일 중 StagingArea에 포함되지 않는 파일이다. 처음 clone을 진행하면, 모든 파일은 Tracked(스냅샷에 포함)파일이지만, Unmodified(수정되지 않았기에)상태이다. 만약 clone 진행 후, 어떤 파일을 수정하게 되면 unmodified -\u0026gt; modified 상태로 상태가 변경되며 실제로 commit을 진행하기 위한 staged 상태를 만들고, staged 상태의 파일을 commit하게 되며, git은 이러한 lifecycle을 반복하게 된다. #\r$ git status\rOn branch master\rYour branch is up-to-date with \u0026#39;origin/master\u0026#39;.\rnothing to commit, working directory clean 위 명령어를 실행하면 현재 하나도 수정되지 않았음을 알려준다. $ echo \u0026#39;My Project\u0026#39; \u0026gt; README\r$ git status\rOn branch master\rYour branch is up-to-date with \u0026#39;origin/master\u0026#39;.\rUntracked files:\r(use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed)\rREADME\rnothing added to commit but untracked files present (use \u0026#34;git add\u0026#34; to\rtrack) README 파일은 “Untracked”에 속해 있는데 이것은 README 파일이 Untracked 상태라는 것을 의미한다. Git은 Untracked 파일을 아직 스냅샷(커밋)에 넣어지지 않은 파일이라고 본다. git init 명령을 실행한 후, git add (files) 명령을 실행했던 걸 기억할 것이다. 이 명령을 통해 디렉토리에 있는 파일을 추적하고 관리하도록 한다. git add 명령은 파일 또는 디렉토리의 경로를 아규먼트로 받는다. #\r$ git add README\r$ git status\rOn branch master\rYour branch is up-to-date with \u0026#39;origin/master\u0026#39;.\rChanges to be committed:\r(use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage)\rnew file: README\rChanges not staged for commit:\r(use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed)\r(use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in workingdirectory)\rmodified: CONTRIBUTING.md git status 명령을 실행하면 README 파일이 Tracked 상태이면서 commit에 추가될 Staged 상태라는 것이 확인이 가능하다. \u0026ldquo;Changes to be commiteed\u0026rdquo; 에 들어 있는 파일은 Staged 상태라는 것을 의미한다. 즉, commit을 실행하면 add를 실행한 시점의 파일이 commit되어 stage -\u0026gt; git history에 남게된다. CONTRIBUTING.md은 \u0026ldquo;Changes not staged for commit\u0026quot;에 있으며, 이는 수정한 파일이 Tracked 상태이지만 아직 Staged 상태는 아니라는 것이며 이는 add 명령어를 통해 staged에 올릴 수 있음을 의미한다. #\r$ git add CONTRIBUTING.md\r$ git status\rOn branch master\rYour branch is up-to-date with \u0026#39;origin/master\u0026#39;.\rChanges to be committed:\r(use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage)\rnew file: README\rmodified: CONTRIBUTING.md add 후 다시 staus를 입력하면 staged 상태로 올라간 것을 확인할 수 있다. #\r$ git status -s\rM README\rMM Rakefile\rA lib/git.rb\rM lib/simplegit.rb\r?? LICENSE.txt #\r이는 위처럼 status -s 옵션을 통해 간단하게 확인할 수 있으며 앞에 문자는 아래와 같은 의미를 가진다. A : New file M : Modified file MM : 작업 디렉터리 및 스테이지 변경 ?? : Untracked Unmodified 파일을 출력되지 않음 #\r파일무시하기\r#\r$ cat .gitignore\r*.[oa]\r*~ .gitignore 파일을 만들고 그 안에 무시할 패턴을 적으면, 해당 패턴과 일치하는 파일들은 commit 되지 않는다. .gitignore은 아래와 같은 특징을 가진다. 아무것도 없는 라인이나, #로 시작하는 라인은 무시한다. 표준 Glob 패턴을 사용한다. 이는 프로젝트 전체에 적용된다. 슬래시(/)로 시작하면 하위 디렉토리에 적용되지(Recursivity) 않는다. 디렉토리는 슬래시(/)를 끝에 사용하는 것으로 표현한다. 느낌표(!)로 시작하는 패턴의 파일은 무시하지 않는다 기타 예제는 (gitignore_repo)[https://github.com/github/gitignore]를 참조하자. #\r변경사항 확인하기\r#\r$ git diff\r$ git diff --staged git status 명령은 특정파일의 Staged 상태인지는 확인할 수 있으나, 변경사항은 확인할 수 없다. git diff 명령을 사용하는데 Patch처럼 어떤 라인을 추가했고 삭제했는지가 궁금할 때 사용한다. #\r$ git log\rcommit ca82a6dff817ec66f44342007202690a93763949\rAuthor: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt;\rDate: Mon Mar 17 21:52:11 2008 -0700\rchanged the version number\rcommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\rAuthor: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt;\rDate: Sat Mar 15 16:40:33 2008 -0700\rremoved unnecessary test\rcommit a11bef06a3f659402fe7563abf99ad00de2209e6\rAuthor: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt;\rDate: Sat Mar 15 10:31:28 2008 -0700\rfirst commit\r$ git log -p -2\rcommit ca82a6dff817ec66f44342007202690a93763949\rAuthor: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt;\rDate: Mon Mar 17 21:52:11 2008 -0700\rchanged the version number\rdiff --git a/Rakefile b/Rakefile\r...\r$ git log --stat\rcommit ca82a6dff817ec66f44342007202690a93763949\rAuthor: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt;\rDate: Mon Mar 17 21:52:11 2008 -0700\rchanged the version number\rRakefile | 2 +-\r1 file changed, 1 insertion(+), 1 deletion(-)\rcommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\r... git log 명령을 실행하면 저장소의 커밋 히스토리를 시간순으로 보여준다. 즉, 가장 최근의 커밋이 가장 먼저 나온다. 그리고 이어서 각 커밋의 SHA-1 체크섬, 저자 이름, 저자 이메일, 커밋한 날짜, 커밋 메시지를 보여준다. -p, \u0026ndash;patch 는 굉장히 유용한 옵션이다. -p 는 각 커밋의 diff 결과를 보여준다. \u0026ndash;stat 옵션으로 각 커밋의 통계 정보를 출력할 수 있다. \u0026ndash;pretty 옵션이다. 이 옵션을 통해 히스토리 내용을 보여줄 때 기본 형식 이외에 여러 가지 중에 하나를 선택할 수 있다. #\r회귀\r#\r#\r$ git commit -m \u0026#39;initial commit\u0026#39;\r$ git add forgotten_file\r$ git commit --amend 위는 실수로 파일을 Stage 하는 것을 깜빡하고 빠트린 파일이 있으면 위와 같이 고칠 수 있다. 하지만, 이는 두 번째 commit이 첫 번째 commit이 완전히 뒤집어 쓰는 것(첫 번째 commit은 히스토리가 없어진다)으로 주의가 필요하다. #\r$ git reset HEAD CONTRIBUTING.md\rUnstaged changes after reset:\rM CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage)\rrenamed: README.md -\u0026gt; README\rChanges not staged for commit:\r(use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed)\r(use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r$ git status\rChanges not staged for commit:\r(use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed)\r(use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working\rdirectory)\rmodified: CONTRIBUTING.md\r$ git checkout -- CONTRIBUTING.md\r$ git status\rOn branch master\rChanges to be committed:\r(use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage)\rrenamed: README.md -\u0026gt; README reset과 staged는 비슷하게 보일 수 있으나, 서로 사용되는 영역이 다른다. reset은 staged영역을 조절하는 데 사용되며, checkout은 주로 브런치 간 이동이나 특정 파일의 변경 내용을 취소하는 데 사용된다. #\r리모트 저장소\r#\r#\r$ git remote -v\rorigin https://github.com/schacon/ticgit (fetch)\rorigin https://github.com/schacon/ticgit (push) remote는 연결되어 있는 저장소를 의미하며, 이는 단지 네트워크 뿐이 아닌 다른 저장소도 의미함을 인지한다. 위 명령어를 통해 현재 연결되어 있는 저장소를 출력할 수 있다. #\r$ git remote\rorigin\r$ git remote add pb https://github.com/paulboone/ticgit\r$ git remote -v\rorigin https://github.com/schacon/ticgit (fetch)\rorigin https://github.com/schacon/ticgit (push)\rpb https://github.com/paulboone/ticgit (fetch)\rpb https://github.com/paulboone/ticgit (push) git remote add \u0026lt;단축이름\u0026gt; 으로 원격 저장소를 연격할 수 있다. "},{"id":3,"href":"/devops/docs/Kubernetes/k8s/k8s/","title":"0. Kubernetes","section":"Kubernetes","content":"\rKubernetes\r#\rKubernetes\r#\r#\r"},{"id":4,"href":"/devops/docs/Kubernetes/k8s/k8s00/","title":"0. Kubernetes","section":"Kubernetes","content":"\rKubernetes\r#\rKubernetes\r#\r#\rkubernetes란 컨테이너화된 워크로드와 서비스를 관리하기 위한 확장가능한 오픈소스 플랫폼이라 할 수 있다. IaC기반으로 선언적 구성과 자동화의 용이하며, 빠르게 성장하는 생태계를 가지고 있다. #\r#\rKubernets가 대두되는 이유\r#\r#\r위 그림은 Traditional Deployment (전통적인 배포), Virtualized Deployment (가상화 배포), Container Deployment(컨테이너 배포)로 나뉘어지고 있으며 각 배포들은 하기와 같은 특징들을 가지고 있다.\n전통적인 배포: 물리 서버에서 배포가 진행되며, 리소스의 한계를 전의할 방법이 없어 성능저하와 여러 장애를 유발 가능성이 존재 가상화 배포: 전통적인 배포에 해결책으로 물리서버 위에 가상화서버(별도의 격리)를 올려 리소스의 한계를 타파하고, 효율을 극대화시킨다. 컨테이너 배포: 컨테이너와 VM은 유사하지만 격리 속성을 완화하여 애플리케이션 간에 운영체제(OS)를 공유하는 특징이 있으며, 프로세스단에서 작동하여 비교적 가볍다고 여겨지며, 기본 인프라와의 종속성을 끊어, 클라우드나 OS 배포본에 상관없이 이식이 가능한 장점을 가지고 있다. 즉, Kubernetes는 컨테이너 배포를 보다 용이하게 관리할 수 있게 해주는 워크로드 관리 플랫폼으로, 현재 관련 기술의 표준으로 자리잡고 있다.\n이러한 kubernetes는 다음과 같은 기능을 제공한다.\n서비스 디스커버리와 로드 밸런싱: 쿠버네티스는 자체 DNS 이름을 사용하거나 자체 IP주소를 사용하여 컨테이너를 노출할 수 있으며, 로드 밸런싱을 배포하여 안정적인 배포가 가능 스토리지 오케스트레이션: 로컬 저장소, 공용 클라우드 공급자와 같이 저장소 시스템의 자동 탑재가 가능 자동화된 롤아웃과 롤백: 사용자의 요구사항에 맞춰 오케스트레이션 서비스의 사용이 가능 자동화된 빈 패킹: 컨테이너화된 작업을 실행하는 데, 클러스터 노드를 사용하여 효율적인 사용이 가능토록 함ㅁ 자동화된 복구: 실패한 컨테이너는 다시시작 및 교체하여 자동으로 형상관리를 진행 시크릿과 구성 관리: OAuth, SSH와 같은 중요한 정보를 저장하고 관리가 가능 #\r#\rkubernetes의 요소\r#\r쿠버네티스의 컴포넌트(요소)는 위 그림의 컴포넌트들을 가진다. 쿠버네티스 클러스터는 컨테이너화된 어플리케이션을 실행하는 노드라고 칭하는 워커머신의 집합을 최소한 한 개를 가지게 된다. #\rControl Plane\r#\r컨트롤 플레인 클러스터에관한 결정적인 결정( 스케쥴링 )을 수행하고 이벤트( 배포 )에 대한 트리거를 감지하고 반응하는 역할을 수행한다. 컨트롤 플레인 클러스터는 어느 노드에게서나 사용이 가능하지만, 보통 컨트롤 프레인 클러스터가 올려진 노드에는 다른 파드를 생성하지 않는다. 컨트롤 플레인은 아래의 컴포넌트들을 포함하고 있다. #\rKube-apiserver\r#\rAPI 서버는 쿠버네티스의 API를 노출하는 쿠버네티스의 컨트롤 컴포넌트이다. 즉, API 서버는 쿠버네티스 컴포넌트의 프론트 엔드라 할 수 있다. kube-apiserver은 수평적으로 확장되도록 디자인이 되어 있어, 더 많은 인스턴스를 배포할 수 있다. 이는 여러 kube-apiserver 인스턴스를 실행하고, 인스턴스간의 트래픽을 균형있게 조절할 수 있게한다. #\retcd\r#\r모든 클러스터 데이터를 담는 쿠버네티스 뒷단의 저장소로 사용되는 일관성, 고가용성 키-값 저장소이다. 즉 쿠버네티스의 모든 정보들은 etcd에 키-값 값으로 저장된다. #\rkube-scheduler\r#\r쿠버 스케쥴러는 노드가 배정되지 않은 새로운 파드를 제공하고, 실행할 노드를 선택하는 컴포넌트이다. 스케쥴링 결정을 위해서 고려되는 여러 요소 ( 리소스, HW, SW, Roul etc )를 모두 포함한다. #\rkube-controller-manager\r#\r컨트롤러의 프로세스를 실행하는 컴포넌트로, 논리적으로 각 컨트롤러는 분리된 프로세스이지만, 복잡성을 낮추기 위해 단일 바이너리 파일로 컴파일되어진다. 해당 컨트롤러는 아래와 같은 종류를 가지고 있다. 노드 컨트롤러: 노드가 다운되었을 때 통지와 대응에 관한 대응 잡 컨트롤러: 일회성 작업을 나타내는 잡 오브젝트를 감시한 다음, 해당 작업을 완료할 때까지 동작하는 파드를 생성 엔드포인트슬라이스 컨트롤러: 서비스와 파드 사이의 연결고리를 제공하기 위한 엔드포인트슬라이스 오브젝트를 생성 서비스어카운트 컨트롤러: 새로운 네임스페이스에 대한 기본 서비스어카운트를 생성 #\rcloud-controller-manager\r#\r클라우드별 컨트롤 로직을 포함하는 쿠버네티스의 컴포넌트로, CSP의 API를 연결하고 해당 플랫폼과 상호작용하는 역할을 수행한다. 이는 로컬에서 실행 중인 경우 해당 컴포넌트는 존재되지 않으며, 존재할 경우 하기의 의존성을 가질 수 있다. 노드 컨트롤러: 노드의 응답이 멈춘 후 클라우드 상에서 삭제되었는 지 판별하기 위해 사업자에게 제공되는 정보 라우트 컨트롤러: 기본 클라우드 인프라에 경로를 구성하는 것 서비스 컨트롤러: 클라우드 제공 사업자 로드밸런서를 생성, 업데이트, 삭제하는 것 #\rnode component\r#\r노트 컴포넌트는 동작 중인 파드를 유지시키고 쿠버네티스 런타임 환경을 제공하며, 모든 노드 상에서 동작한다. #\rkubelet\r#\r각 노드에서 실행되는 에이전트로, 각 파드에서 컨테이너가 확실하게 동작하도록 관리하는 역할을 수행한다. 단, 쿠버네티스를 통해서 생성된 컨테이너만을 관리하며, 그 외 컨테이너는 관리하지 않는다. #\rkube-proxy\r#\r쿠버 프록시는 각 노드에서 실행되는 네트워크 프록시로, 쿠버네티스 서비스 개념의 구현부분이다. 즉, 쿠버 프록시는 각 노드의 네트워크 규칙을 유지 및 관리하며, 해당 규칙으로 내부 네트워크 세션이나 클러스터 바깥 파드로 네트워크 통신을 가능토록 한다. 운영 체제에 가용한 패킷 필터링이 있는 경우에는 이를 사용하고, 그렇지 않으면 자체 포워드를 사용한다. #\r애드온\r#\r애드온은 쿠버네티스 리소스(데몬셋, 디폴로이먼트 등)을 이용하여 클러스터 기능을 구현하며, 클러스터 단위의 기능을 제공한다. 애드온에 대한 네임스페이스 리소스는 kube-system 네임스페이스에 속한다. #\rDNS\r#\r모든 쿠버네티스 요소들을 클러스터의 DNS를 갖추어야만 한다. 클러스터 DNS는 구성환경 내 다른 DNS 서버와 더불어, 쿠버네티스 서비스를 위해 DNS 레코드를 제공해 주는 DNS 서버를 의미한다. #\r웹 UI ( 대시보드 )\r#\r대시보드는 쿠버네티스 클러스터를 위한 웹 기반 UI이며, 웹을 통해 관리 및 문제 해결을 도와준다. #\r컨테이너 리소스 모니터링\r#\r중앙 데이터베이스 내의 컨테이너들에 대한 포괄적인 시게열 매트릭스를 기록하고 그 데이터를 열함하기 위한 UI를 제공해 준다. #\r클러스터-레벨 로깅\r#\r검색/ 열람 인터페이스와 함께 중앙 로그 저장소에 컨테이너 로그를 저장하는 역할을 수행한다. "},{"id":5,"href":"/devops/docs/Kubernetes/k8s/k8s01/","title":"1. Kubernetes Object","section":"Kubernetes","content":"\rKubernetes Object\r#\rKubernetes Object\r#\r쿠버네티스의 오브젝트란 시스템에서 영속성을 가지는 명세서를 의미하며, 이는 아래와 같이 기술할 수 있다.\n어떤 노드에서 어떤 파드 및 어플리케이션의 동작 유무 해당 어플리케이션의 사용가능 리소스 해당 어플레케이션의 재구동 정책, 업그레이드, 가용성 등의 대한 동작 정책 즉, 쿠버네티스 오브젝트란 하나의 의도를 담은 명세서를 의미하며, 이를 생성하게되면 쿠버네티스 상에서는 해당 오브젝트의 영속성을 보장하기 위해 지속적으로 동작할 것이고, 이를 통해 하나 혹은 몇몇의 오브젝트로 사용자의 워크로드의 관리가 보다 쉽게 가능해진다.\n#\r오브젝트의 Spec, Status\r#\r대부분의 쿠버네티스 오브젝트는 구성을 결정해주는 오브젝트 필드를 포함하게 되는 데, 이는 spec과 status다. spec은 해당 오브젝트를 생성할 때 리소스에 필요한 요청사항을 제공하여 설정한다. status는 쿠버네티스와 요소간 제공되고 업데이트된 오브젝트의 현재 상태를 의미한다. #\r오브젝트 기술하기\r#\rapiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment spec: selector: matchLabels: app: nginx replicas: 2 # tells deployment to run 2 pods matching the template template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 위는 .yaml 파일을 이용하여 디플로이먼트를 생ㅅ어하기 위한 방식으로 kubectl을 사용하여 쿠버네티스 API를 호출하여 반영시키는 방식이다. $ kubectl apply -f deployment.yaml deployment.apps/nginx-deployment created 위와 같이 생성하고자 하는 오브젝트에 대한 .yaml 파일 내에 해당 값을을 설정해줘야 한다.\napiVersion: 해당 파일의 오브젝트를 사용하기 위한 쿠버네티스의 API 버전이 어떤 것인지 kind: 어떤 종류의 오브젝트를 생성하려는 지 metadata: 이름, 문자열, UID, namespace 등을 포함하여 오브젝트를 구분하게 해 줄 데이터 spec: 오브젝트의 상태를 기술 spec은 각 오브젝트마다 (kind)마다 다르기에 각자 다른 템플릿이 존재하고, 이는 요청에 따라 값이 달라지기 때문에 많은 경험을 필요로 한다.\n#\r#\rObject Management\r#\r#\r오브젝트를 관리하는 방법으로는 아래와 같이 명령형 커맨드, 명령형 오브젝트 구성, 선언형 오브젝트 구성으로 나뉘어져 있다. 관리기법 대상 권장 환경 지원하는 작업자 수 학습 난이도 명령형 커맨드 활성 오브젝트 개발 환경 1+ 낮음 명령형 오브젝트 구성 개별 파일 프로덕션 환경 1 보통 선언형 오브젝트 구성 파일이 있는 디렉터리 프로덕션 환경 1+ 높음 #\r명령형 커맨드\r#\r$ kubetl create deployment nginx --image nginx 명령형 커맨드의 경우 클러스터 내 활성 오브젝트를 대상으로 직접 동작시키며, 사용자는 실행할 작업을 인수 또는 플래그로 kubectl 커맨드를 호출한다. 이는 일회성 작업의 개념으로 추천하지 않는 방법이며, 직접적인 영향을 끼치고, 이전 구성에 대한 이력을 제공해주지 않아 문제가 발생시 대응이 어렵다. #\r명령형 오브젝트 구성\r#\r명령형 오브젝트 구성은 kubectl, 선택적 플래그, 파일이름을 사용하여 이미 정의된 파일을 통해 생성한다. $ cat nginx.yaml apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment spec: selector: matchLabels: app: nginx replicas: 2 # tells deployment to run 2 pods matching the template template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 $ kubectl create -f nginx.yaml $ kubectl delete -f nginx.yaml -f redis.yaml 오브젝트를 파일로 관리함으로써, Git 과 같은 소스 컨트롤 시스템에 보관이 가능하다. 관련 히스토리 및 감사의 추적이 보다 쉽고, 프로세스들과의 통합에 유용하다. #\r선언형 오브젝트 구성\r#\r선언형 오브젝트는 명령형 오브젝트와 동일하게 오브젝트 구성 파일을 대상으로 작동시키지만, 선연형 오브젝트는 한 파일의 관련 오브젝트들이 명시되어 있는 반면, 선언형 오브젝트는 각 오브젝트 구성파일이 나뉘어져 있다는 점에 차이가 있다. $ kubectl diff -f configs/ $ kubectl apply -f configs/ $ kubectl diff -R -f configs/ $ kubectl apply -R -f configs/ #\r레이블과 셀렉터\r#\r#\r레이블\r#\r레이블은 파드와 같은 오브젝트에 첨부된 키와 값의 쌍이며, 이는 오브젝트의 특성을 식별하는 데 사용되어 사용자에게는 중요하지만 코어 시스템에 직접적인 의미는 없다. \u0026#34;metadata\u0026#34;: { \u0026#34;labels\u0026#34;: { \u0026#34;key1\u0026#34; : \u0026#34;value1\u0026#34;, \u0026#34;key2\u0026#34; : \u0026#34;value2\u0026#34; } } 레이블은 UI와 CLI에서 효율적인 쿼리를 사용하고 검색에 사용하기 적합하며, 식별되지 않는 정보는 어노테이션으로 기록해야 한다. 레이블은 키와 값 쌍으로 이루어져 있으며, 유효한 레이블 키에는 슬래시(/)로 구분된다. 접두사를 생략한 레이블은 개인용으로 간주하며, 시스템 컴포넌트(kube-scheduler, kube-controller-manager, kube-apiserver, kubectl) 또는 다른 타사의 자동화 구성요서의 접두사를 지정해야한다. kubernetes.io/ 와 k8s.io/ 접두사는 쿠버네티스의 핵심 컴포넌트로 에약되어 있다.\napiVersion: v1 kind: Pod metadata: name: label-demo labels: environment: production app: nginx spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 위는 environment: production, app: nginx 2개의 레이블이 있는 구성 파일이다. 위처럼 이름과 UID와 다르게 레이블은 고유하지 않으며, 일반적으로 라벨과 비슷한 역할을 한다. 사용자는 레이블 셀렉터를 통해 해당 오브젝트들을 식별할 수 있다. #\r집합성 기준 요건\r#\renvironment in (production, qa) # (enviromen:prodction), (environment:qa) 리소스를 선택한다. / =\rtier notin (frontend, backend) # (tier:frontend), (tier:backend) 리소스를 제외하고 선택한다. / !=\rpartition # partition을 포함한 모든 리소스를 선택한다.\r!partition # partition을 포함하지 않는 모든 리소스를 선택한다. 집합성 기준은 위와 같이 in, notion, exists 의 3개 연산자를 지원한다. #\r셀렉터\r#\rselector: matchLabels: component: redis matchExpressions: - {Key: tier, operator: In, Values: [cache]} - {key: environment, operator: NotIn, values: [dev]} services에서 지정하는 파드 집합은 레이블 셀럭터로 정의한다. 위와 동일하게 replicationcontrollers가 관리하는 파드의 오브젝트 구릅도 레이블 셀렉터로 정의한다. "},{"id":6,"href":"/devops/docs/CICD/CICD/with-toc/","title":"1. 학습목표","section":"CI/CD 배포 입문","content":"\r학습목표\r#\r클라우드 서비스를 활용하기 위한 기본 지식 학습\n클라우드 서비스에 내 프로젝트를 단순 배포하기 위한 환경을 구축\n클라우드 서비스 내 프로젝트 배포를 간편화\n클라우드 서비스에 환경 구축 없이 프로젝트 배포 ( Elastic Beanstalk )\n클라우드 서비스에 배포 자동화\n클라우드 서비스 무중단 배포\n정적 IP 할당을 위한 NLB 활용\n최종목표\n스프링 부트를 사용한 간단한 프로젝트를 생성 후, 배포 "},{"id":7,"href":"/devops/docs/CICD/CICD/table-of-contents/with-toc/","title":"With ToC","section":"Table of Contents","content":"\rCaput vino delphine in tamen vias\r#\rCognita laeva illo fracta\r#\rLorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\nTe at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit Natus quaerere\r#\rPectora et sine mulcere, coniuge dum tincta incurvae. Quis iam; est dextra Peneosque, metuis a verba, primo. Illa sed colloque suis: magno: gramen, aera excutiunt concipit.\nPhrygiae petendo suisque extimuit, super, pars quod audet! Turba negarem. Fuerat attonitus; et dextra retinet sidera ulnas undas instimulat vacuae generis? Agnus dabat et ignotis dextera, sic tibi pacis feriente at mora euhoeque comites hostem vestras Phineus. Vultuque sanguine dominoque metuit risi fama vergit summaque meus clarissimus artesque tinguebat successor nominis cervice caelicolae.\nLimitibus misere sit\r#\rAurea non fata repertis praerupit feruntur simul, meae hosti lentaque citius levibus, cum sede dixit, Phaethon texta. Albentibus summos multifidasque iungitur loquendi an pectore, mihi ursaque omnia adfata, aeno parvumque in animi perlucentes. Epytus agis ait vixque clamat ornum adversam spondet, quid sceptra ipsum est. Reseret nec; saeva suo passu debentia linguam terga et aures et cervix de ubera. Coercet gelidumque manus, doluit volvitur induta?\nEnim sua\r#\rIuvenilior filia inlustre templa quidem herbis permittat trahens huic. In cruribus proceres sole crescitque fata, quos quos; merui maris se non tamen in, mea.\nGermana aves pignus tecta\r#\rMortalia rudibusque caelum cognosceret tantum aquis redito felicior texit, nec, aris parvo acre. Me parum contulerant multi tenentem, gratissime suis; vultum tu occupat deficeret corpora, sonum. E Actaea inplevit Phinea concepit nomenque potest sanguine captam nulla et, in duxisses campis non; mercede. Dicere cur Leucothoen obitum?\nPostibus mittam est nubibus principium pluma, exsecratur facta et. Iunge Mnemonidas pallamque pars; vere restitit alis flumina quae quoque, est ignara infestus Pyrrha. Di ducis terris maculatum At sede praemia manes nullaque!\n"},{"id":8,"href":"/devops/docs/CICD/CICD/key/","title":"암호화","section":"CI/CD 배포 입문","content":"\r암호화의 기술과 역사\r#\r암호화의 역사\r#\r시대 기간 특징 종류 고대 고대 - 19세기 말 수동 암호 사용 (단순, 문자 대입하여 암호화) Scytale, Caesar, Vigenere, Beaufort 등 근대 1900 - 1940년대 기계 암호 사용 (복잡한 기계를 이용하여 암호화) Enigma, M-209 등 현대 1950년대 - 현재 샤뇬의 \u0026ldquo;암호학의 수학적 배경\u0026rdquo; 발표 이후 시작, 컴퓨터 암호 사용 (컴퓨터 연산을 이용하여 암호화) DES, SEED, Rijindael, RSA, ECC, KCDSA 등 고대에는 외교, 군사 등의 한정적인 분야의 사용되었으나, 현대에는 인터넷, 전자상거래 등이 발달하면서 전반적인 분야의 대한 보안(암호화)의 기능이 중요시 되기 시작했다. 현대 암호화 기술\r#\r1. 대칭키 암호화 기술 (비밀키)\r#\r송신자와 수신자간의 데이터가 오갈 때, 암호화 및 복호화를 동일한 Key로 진행하는 방식 즉, 송신자 A가 수신자 B에게 특정 파일을 Q라는 Key를 사용하여 암호화해서 보내면, B는 A가 사용했던 Q라는 key를 사용하여 복호화해야만 받은 파일의 확인이 가능하다. 대칭키 암호화는 블록, 스트링 암호를 사용하며, 특징은 아래와 같다. 블록암호(DES): Data Encryption Standard의 약자로 1976년 미국가표준국(NIST) 주도하에 설계된 암호화 방식이다. 63비트 단위의 블록 길이로 암호화한다. 블록 중 키의 길이는 58비트 나머지 8비트는 패리티 체크에 사용 블록암호(AES): DES의 해독 방법이 나오면서 DES를 대체하기 위하여 채택된 방식이다. Advanced Encryption Standard의 약자로 1997년부터 진행하여, 2001년 존 대먼과 빈센트 라이언이 개발한 Rijndael의 알고리즘을 기반하여 만들어졌다. 128비트로 DES보다 더 큰 단위의 블록 길이로 암호화한다. 128비트뿐만 아니라 192비트, 256비트 길이로 암호화 가능 스트링암호: 데이터 스트림(흐름)을 순차적으로 처리해가는 암호 알고리즘으로 데이터가 발생하는 즉시 암호화하여 보내는 방식, 1비트, 8비트, 또는 32 비트 등의 단위로 암호화와 복호화를 진행 구분 블록암호 스트링암호 장점 암호 복잡성이 높고, 기밀성이 높고, 해시 함수를 사용하여 암호화한다. 암호화 속도가 빠르며, 비트 단위로 암호화하기 때문에 다음 한 비트의 에러 발생이 다음 비트에 영향을 주지 않는다. 단점 암호화 속도가 느리며, 블록 내부의 한 비트의 에러 발생이 다른 비트에 쉽게 에러 전달된다. 암호화의 확산이 낮기 때문에 암호의 복잡성이 떨어지며, 비트 단위로 암호화가 진행되기 때문에 비트 사이에 삽입 변경 쉬워, 삽입공격에 취약하다 종류 DES, IDES, SEED, RC5, AES LFSR(Shift Register), MUX generator 암호화 단위 블록 비트 주요대상 일반 데이터 전송, 저장 음성, 오디오/비디오 스트리밍 실시간 부적합 적합 2. 비대칭 암호화 기술 (공개키)\r#\r암호화를 위한 키와, 복호화를 위한 키가 다른 암호화 방식을 말한다. RSA(Rivest, Shamir, Adleman), ECC(Elliptic Curve Cryptosystem), NTRU, XTR 등이 존재한다. 비대칭 암호화 기술은 Public, Private Key 기술을 활용하며, 송신자 A가 수신자 B에게 파일을 보낸다면, 먼저 수신자 B의 Public Key를 사용하여 암호화 시킨 후 발송하면, 이 파일은 Private Key가 있는 B만이 복호화하여 파일을 열 수 있는 구조이다. 3. PKI (Public Key Infrastructure, 공개키기반구조)\r#\rPKI는 위에서 언급한 공개키 암호화와 전자서명을 사용할 수 있게 구조를 제시해 둔 것이다. 기존 공개키 방식은 해커 C가 A가 B에게 암호화 통신 중간에 끼어들어, B가 A에게 다시 파일을 보낼 때, 자신의 공공키를 제시하는 식의 문제가 생기기 시작했고, 이를 예방하기 위해 PKI라는 개념을 등장시켰다. PKI는 공개키 기반 구조를 가지기 위해 비대칭키 암호화 방식에서 CA라는 개념을 등장 시킨다. PKI 구성요소는 아래와 같다. 인증기관(CA, Certificate Authority): 사용자의 인증서 발급 및 관리 Ex) 한국정보인증(KICA), 금융결제원(yesSign), 한국진흥정보원(Sigate) 등 등록기관(RA, Registration Authority): 신원확인, 고객 데이터 유지 등 인증기관의 입증을 대행하는 등록기관. Ex) 은행, 증권사 디렉토리(Directory): 인증서 및 인증서 취소목록 등 PKI와 관련된 정보를 저장 및 검색하는 장소 인증서(Certificate): 공개키나 공개키의 정보를 포함하는 인증서 Ex) X.509 인증서 4. SSL/TLS\r#\rSSL/TLS는 프로토콜로 PKI가 제공하는 공개 키 인프라와 디지털 인증서를 사용해서 Browser와 server 간 통신. 즉 Website 트랜잭션에 보안 및 무결성을 제공하는 기술이다. SSL (Secure Socket Layer): Browser와 Server가 서로 통신할 때 보안 및 무결성을 제공하는 프로토콜 TLS (Transport Layer Security): SSL과 마찬가지로 Browser와 Server가 서로 통신할 때 보안 및 무결성을 제공하는 프로토콜 즉 SSL과 TLS는 동일한 목적을 수행하는 프로토콜이지만 차이점이라면 TLS 프로토콜은 SSL 프로토콜의 업데이트된 상위 버전이라는 것으로, SSL이 표준화 되면서 이름이 TLS로 변경되었다. 4-1. TLS 통신과정 (Handshake과정)\r#\r클라이언트에서 서버로 접속한다. (https://URL) 클라이언트는 랜덤데이터를 만들어 서버에 보낸다. 클라이언트에서 사용 가능한 암호화방식들을 서버에 보낸다. 서버 -\u0026gt; 클라이언트 서버 또한 랜덤데이터를 만들어 클라이언트에 보낸다. 클라이언트가 보낸 암호화방식들 중에 사용할 방식을 선정하여 클라이언트에 보낸다. SSL 인증서도 같이 보낸다. (SSL 인증서에는 사이트의 Public Key, CA, 도메인 정보등이 존재) 5. 실습\r#\r$ brew install mkcert\r# 인증을 위한 패키지 설치\r$ mkcert -install\r# localhost 인증된 발급기관 추가(localhost용 ca)\r$ mkcert -key-file key.pem -cert-file cert.pem localhost 127.0.0.1 ::1\r# localhost, 127.0.0.1(IPv4), ::1(IPv6)에서 사용할 수 있는 인증서 생성 cert.pem, key.pem이라는 파일이 생성 cert.pem 파일의 경우 공개키와 인증기관의 서명을 포함하고 있는 인증서이며, key.pem의 경우 개인 키 # https.js 파일 생성 후 확인\rconst https = require(\u0026#39;https\u0026#39;);\rconst fs = require(\u0026#39;fs\u0026#39;);\rhttps\r.createServer(\r{\rkey: fs.readFileSync(\u0026#39;./key.pem\u0026#39;, \u0026#39;utf-8\u0026#39;),\rcert: fs.readFileSync(\u0026#39;./cert.pem\u0026#39;, \u0026#39;utf-8\u0026#39;),\r},\rfunction (req, res) {\rres.write(\u0026#39;Congrats! You made https server now :)\u0026#39;);\rres.end();\r}\r)\r.listen(443);\r$ sudo node https.js\r$ curl localhost:443\rCongrats! You made https server now :) https:localhost:443 으로 접속하여도 자물쇠 아이콘을 확인할 수 있음 Reference https://m.blog.naver.com/taeheon714/222278059898 https://byoungsoo.github.io/etc/2022/06/08/pki.html https://swingswing.tistory.com/155 "},{"id":9,"href":"/devops/docs/Docker/Docker/Docker01/","title":"1. Docker 기본 명령어","section":"Docker","content":"\rDocker\r#\rDocker 기본 명령어\r#\r컨테이너 생성\r#\r$ docker run [OPTION] NAME[:TAG|@DIGEST] OPTION 특징 -d, \u0026ndash;detach 백그라운드에서 실행합니다. -i, \u0026ndash;interactive 상호적으로 실행하며, 표준 입력을 유지합니다. -t, \u0026ndash;tty 할당된 tty를 사용하여 실행합니다. \u0026ndash;name 컨테이너에 이름을 할당합니다. -e, \u0026ndash;env 컨테이너 내에서 사용할 환경 변수를 설정합니다. \u0026ndash;rm 컨테이너가 종료되면 자동으로 삭제합니다. \u0026ndash;network 컨테이너가 사용할 네트워크를 지정합니다. \u0026ndash;publish, -p 호스트와 컨테이너 간의 포트 매핑을 설정합니다. \u0026ndash;volume, -v 호스트와 컨테이너 간의 볼륨 매핑을 설정합니다. \u0026ndash;help 도움말을 표시합니다. Network 생성\r#\r$ docker network create [OPTIONS] NETWORK 옵션 설명 -d 네트워크 드라이버 지정 (기본값: bridge) \u0026ndash;subnet 네트워크의 서브넷 설정 \u0026ndash;gateway 네트워크의 게이트웨이 IP 설정 \u0026ndash;ip-range 네트워크의 IP 범위 설정 \u0026ndash;attachable 기존 네트워크에 컨테이너 연결 허용 \u0026ndash;internal 외부에서의 네트워크 접근 제한 \u0026ndash;label 네트워크에 메타데이터 설정 \u0026ndash;opt 드라이버별 옵션 설정 \u0026ndash;ipv6 IPv6 지원 활성화 \u0026ndash;ipam-driver IP 주소 관리 드라이버 지정 \u0026ndash;ipam-opt IP 주소 관리 옵션 설정 \u0026ndash;attachable 기존 네트워크에 컨테이너 연결 허용 \u0026ndash;internal 외부에서의 네트워크 접근 제한 \u0026ndash;ingress 인그레스 네트워크 생성 \u0026ndash;ingress-opt 인그레스 옵션 설정 volume 생성\r#\r$ docker volume create [OPTIONS] STORAGE 옵션 설명 \u0026ndash;storage-driver 사용할 스토리지 드라이버 설정 \u0026ndash;volume-driver 사용할 볼륨 드라이버 설정 \u0026ndash;add-registry 이미지를 가져올 도커 레지스트리 추가 \u0026ndash;disable-content-trust 이미지에 대한 콘텐츠 신뢰 기능 비활성화 \u0026ndash;icc 컨테이너 간 통신 허용 여부 설정 \u0026ndash;live-restore 도커 데몬 재시작 시 컨테이너 자동 복구 설정 \u0026ndash;log-driver 로깅 드라이버 설정 \u0026ndash;log-level 로깅 레벨 설정 \u0026ndash;storage-opt 스토리지 드라이버 옵션 설정 \u0026ndash;selinux-enabled SELinux 지원 여부 설정 \u0026ndash;storage-opt 스토리지 드라이버 옵션 설정 \u0026ndash;tls TLS 보안 연결 설정 \u0026ndash;tlscacert TLS CA 인증서 파일 경로 설정 \u0026ndash;tlscert TLS 인증서 파일 경로 설정 \u0026ndash;tlskey TLS 키 파일 경로 설정 \u0026ndash;tlsverify TLS 연결 검증 설정 컨테니어 시작\r#\r$ docker start [OPTION] OPTION 특징 -d, \u0026ndash;detach 백그라운드에서 실행합니다. -i, \u0026ndash;interactive 상호적으로 실행하며, 표준 입력을 유지합니다. -t, \u0026ndash;tty 할당된 tty를 사용하여 실행합니다. \u0026ndash;name 컨테이너에 이름을 할당합니다. -e, \u0026ndash;env 컨테이너 내에서 사용할 환경 변수를 설정합니다. \u0026ndash;rm 컨테이너가 종료되면 자동으로 삭제합니다. \u0026ndash;network 컨테이너가 사용할 네트워크를 지정합니다. \u0026ndash;publish, -p 호스트와 컨테이너 간의 포트 매핑을 설정합니다. \u0026ndash;volume, -v 호스트와 컨테이너 간의 볼륨 매핑을 설정합니다. \u0026ndash;help 도움말을 표시합니다. 컨테이너 목록 확인\r#\r$ docker ps [OPTION] OPTION 특징 -a, \u0026ndash;all 모든 컨테이너를 출력합니다. (종료된 컨테이너 포함) -q, \u0026ndash;quiet 컨테이너 ID만 출력합니다. \u0026ndash;no-trunc 출력을 자르지 않고 전체 정보를 표시합니다. -n, \u0026ndash;last n 최근 n개의 컨테이너만 표시합니다. -s, \u0026ndash;size 각 컨테이너의 크기 정보를 표시합니다. \u0026ndash;format 사용자 지정 포맷으로 출력합니다. \u0026ndash;filter 필터를 적용하여 특정 조건을 만족하는 컨테이너만 표시합니다. \u0026ndash;help 도움말을 표시합니다. 컨테이너 중지\r#\r$ docker stop [OPTIONS] CONTAINER [CONTAINER...] OPTION 특징 -t, \u0026ndash;time 정지 프로세스에 대한 타임아웃(초)을 설정합니다. 기본값은 10초입니다. \u0026ndash;help 도움말을 표시합니다. 컨테이너 제거\r#\r$ docker rm [OPTIONS] CONTAINER [CONTAINER...] OPTION 특징 -f, \u0026ndash;force 실행 중인 컨테이너를 강제로 중지하고 제거합니다. -v, \u0026ndash;volumes 컨테이너와 관련된 볼륨을 함께 제거합니다. \u0026ndash;link 컨테이너를 다른 컨테이너에 연결한 경우 해당 연결을 제거합니다. \u0026ndash;help 도움말을 표시합니다. 이미지 확인\r#\r$ docker images [OPTIONS] [REPOSITORY[:TAG]] OPTION 특징 -a, \u0026ndash;all 모든 이미지를 표시합니다. \u0026ndash;digests 각 이미지의 다이제스트 정보를 표시합니다. \u0026ndash;format 사용자 지정 포맷으로 출력합니다. \u0026ndash;no-trunc 출력을 자르지 않고 전체 정보를 표시합니다. -q, \u0026ndash;quiet 이미지 ID만 출력합니다. \u0026ndash;help 도움말을 표시합니다. 이미지 다운로드\r#\r$ docker pull [OPTIONS] NAME[:TAG|@DIGEST] OPTION 특징 -a, \u0026ndash;all-tags 이미지의 모든 태그를 가져옵니다. \u0026ndash;disable-content-trust 이미지의 내용 신뢰 기능을 비활성화합니다. \u0026ndash;help 도움말을 표시합니다. 이미지 삭제\r#\r$ docker rmi [OPTIONS] IMAGE [IMAGE...] 컨테이너 접속\r#\r$ docker exec [OPTIONS] CONTAINER COMMAND [ARG...] OPTION 특징 -d, \u0026ndash;detach 백그라운드에서 실행합니다. -i, \u0026ndash;interactive 상호적으로 실행하며, 표준 입력을 유지합니다. \u0026ndash;env 컨테이너 내에서 사용할 환경 변수를 설정합니다. \u0026ndash;user 명령을 실행할 사용자 또는 UID를 지정합니다. \u0026ndash;workdir 명령을 실행할 작업 디렉토리를 지정합니다. \u0026ndash;tty 할당된 tty를 사용하여 실행합니다. \u0026ndash;help 도움말을 표시합니다. 컨테이너 로그 확인\r#\r$ docker logs [OPTIONS] CONTAINER OPTION 특징 \u0026ndash;details 로그 항목의 추가 세부 정보를 표시합니다. -f, \u0026ndash;follow 실시간으로 로그를 출력하며, 계속해서 갱신됩니다. \u0026ndash;since 특정 시간 이후의 로그만 표시합니다. \u0026ndash;tail 지정된 개수의 최근 로그 항목만 표시합니다. -t, \u0026ndash;timestamps 로그 항목에 타임스탬프를 표시합니다. \u0026ndash;until 특정 시간 이전의 로그만 표시합니다. \u0026ndash;help 도움말을 표시합니다. 이미지 생성\r#\r$ docker commit [OPTION] [CONTAINER] [NAME] OPTION 특징 -a, \u0026ndash;author 커미트한 사용자를 지정합니다. -c, \u0026ndash;change 이미지 생성 시 Dockerfile 형식으로 변경을 추가합니다. -m, \u0026ndash;message 커밋에 대한 설명 또는 메시지를 추가합니다. -p, \u0026ndash;pause 커밋 시 컨테이너를 일시 중지합니다. "},{"id":10,"href":"/devops/docs/Docker/Docker/Docker02/","title":"2. Docker Registry","section":"Docker","content":"\rDocker\r#\rDocker Registry\r#\rRegistry\r#\rDocker의 Registry는 이미지를 저장하는 장소이며 크게 Docker Hub, Private Registry로 나뉘어진다. Private Registry는 내부망, 로컬으로 나뉘어진다. Docker Hub 사용\r#\r$ docker login ... $ docker tag Push_image [ID]/[Image_name] $ docker pull [ID]/[REPO] "},{"id":11,"href":"/devops/docs/Docker/Docker/Docker03/","title":"3. Dockerfile\u0026 Compose","section":"Docker","content":"\rDocker\r#\rDockerfile\r#\rDockerfile\r#\rInstruction 설명 ADD 로컬 또는 원격 파일 및 디렉토리 추가 ARG 빌드 시간 변수 사용 CMD 기본 명령어 지정 COPY 파일 및 디렉토리 복사 ENTRYPOINT 기본 실행 파일 지정 ENV 환경 변수 설정 EXPOSE 응용 프로그램이 수신 대기 중인 포트 설명 FROM 기본 이미지에서 새 빌드 단계 생성 HEALTHCHECK 컨테이너의 시작 시간에 대한 건강 상태 확인 LABEL 이미지에 메타데이터 추가 MAINTAINER 이미지 작성자 지정 ONBUILD 이미지가 빌드에 사용될 때 지시 RUN 빌드 명령어 실행 SHELL 이미지의 기본 셸 설정 STOPSIGNAL 컨테이너 종료에 대한 시스템 콜 신호 지정 USER 사용자 및 그룹 ID 설정 VOLUME 볼륨 마운트 생성 WORKDIR 작업 디렉토리 변경 Dockerfile 예시\r#\r# 기본 이미지로부터 빌드 스테이지 생성 FROM ubuntu:latest # 로컬 또는 원격 파일 및 디렉토리 추가 ADD ./app /app # 빌드 시간 변수 사용 ARG version=1.0 # 기본 명령어 지정 CMD [\u0026#34;./app/start.sh\u0026#34;] # 파일 및 디렉토리 복사 COPY ./config /config # 기본 실행 파일 지정 ENTRYPOINT [\u0026#34;/app/entrypoint.sh\u0026#34;] # 환경 변수 설정 ENV APP_HOME=/app # 응용 프로그램이 수신 대기 중인 포트 설명 EXPOSE 8080 # 건강 상태 확인 HEALTHCHECK CMD curl --fail http://localhost:8080/ || exit 1 # 이미지에 메타데이터 추가 LABEL version=$version LABEL maintainer=\u0026#34;Your Name \u0026lt;your.email@example.com\u0026gt;\u0026#34; # 이미지 작성자 지정 MAINTAINER Your Name \u0026lt;your.email@example.com\u0026gt; # 이미지가 빌드에 사용될 때 지시 ONBUILD ADD . /app/src ONBUILD RUN /app/build.sh # 빌드 명령어 실행 RUN apt-get update \u0026amp;\u0026amp; apt-get install -y \\ package1 \\ package2 \\ \u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/* # 이미지의 기본 셸 설정 SHELL [\u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;] # 컨테이너 종료에 대한 시스템 콜 신호 지정 STOPSIGNAL SIGTERM # 사용자 및 그룹 ID 설정 USER 1000:1000 # 볼륨 마운트 생성 VOLUME /app/data # 작업 디렉토리 변경 WORKDIR /app Docker compose\r#\rversion: \u0026#39;3\u0026#39; # 도커 컴포즈 버전 지정 services: # 서비스 정의 시작 web: # 서비스 이름 image: nginx:latest # 도커 이미지 지정 ports: - \u0026#34;8080:80\u0026#34; # 호스트와 컨테이너 포트 매핑 volumes: - ./web-content:/usr/share/nginx/html # 볼륨 매핑 networks: - frontend # 네트워크 지정 db: image: mysql:latest environment: MYSQL_ROOT_PASSWORD: example # 환경 변수 설정 volumes: - db-data:/var/lib/mysql networks: - backend networks: frontend: # 사용자 정의 네트워크 정의 backend: volumes: db-data: # 사용자 정의 볼륨 정의 옵션 설명 -f, \u0026ndash;file 컴포즈 설정 파일 지정 (기본값: docker-compose.yml) -p, \u0026ndash;project-name 프로젝트 이름 설정 (기본값: 디렉터리 이름) -v, \u0026ndash;verbose 자세한 출력 활성화 -q, \u0026ndash;quiet 출력을 최소화 \u0026ndash;log-level 로그 레벨 설정 (기본값: INFO) \u0026ndash;no-ansi ANSI 제어 코드를 사용하지 않음 \u0026ndash;version 버전 정보 출력 \u0026ndash;help 도움말 출력 -H, \u0026ndash;host 컴포즈 엔진에 연결할 Docker 호스트 설정 \u0026ndash;compatibility 호환성 모드 활성화 (v3 이하의 구성 파일 사용) \u0026ndash;env-file 환경 파일에서 변수 지정 \u0026ndash;project-directory 프로젝트 디렉터리 설정 (기본값: 현재 디렉터리) \u0026ndash;compatibility 호환성 모드 활성화 (v3 이하의 구성 파일 사용) \u0026ndash;project-directory 프로젝트 디렉터리 설정 (기본값: 현재 디렉터리) \u0026ndash;compatibility 호환성 모드 활성화 (v3 이하의 구성 파일 사용) \u0026ndash;project-directory 프로젝트 디렉터리 설정 (기본값: 현재 디렉터리) \u0026ndash;compatibility 호환성 모드 활성화 (v3 이하의 구성 파일 사용) \u0026ndash;project-directory 프로젝트 디렉터리 설정 (기본값: 현재 디렉터리) \u0026ndash;compatibility 호환성 모드 활성화 (v3 이하의 구성 파일 사용) \u0026ndash;project-directory 프로젝트 디렉터리 설정 (기본값: 현재 디렉터리) "},{"id":12,"href":"/devops/docs/Docker/Docker/Docker04/","title":"4. Docker 실습","section":"Docker","content":"\rDocker\r#\r#\r"},{"id":13,"href":"/devops/docs/CICD/CICD/table-of-contents/","title":"Table of Contents","section":"CI/CD 배포 입문","content":"\rUbi loqui\r#\rMentem genus facietque salire tempus bracchia\r#\rLorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice\r#\rOra precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis\r#\rNefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral),\rnorthbridge_services_troubleshooting, personal(\rfirmware_rw.trash_rw_crm.device(interactive_gopher_personal,\rsoftware, -1), megabit, ergonomicsSoftware(cmyk_usb_panel,\rmips_whitelist_duplex, cpa)));\rif (5) {\rmanagementNetwork += dma - boolean;\rkilohertz_token = 2;\rhoneypot_affiliate_ergonomics = fiber;\r}\rmouseNorthbridge = byte(nybble_xmp_modem.horse_subnet(\ranalogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet),\rgateway_ospf), repository.domain_key.mouse(serverData(fileNetwork,\rtrim_duplex_file), cellTapeDirect, token_tooltip_mashup(\rripcordingMashup)));\rmodule_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) +\rcoreLog.joystick(componentUdpLink), windows_expansion_touchscreen);\rbashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling(\rciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);\rPlacabilis coactis nega ingemuit ignoscat nimia non\r#\rFrontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) {\rzif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive;\rgigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop),\rpanel_point_firmware);\rspyware_bash.statePopApplet = express_netbios_digital(\rinsertion_troubleshooting.brouter(recordFolderUs), 65);\r}\rrecursionCoreRay = -5;\rif (hub == non) {\rportBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard),\rfont_radcab, guidCmsScalable + reciprocalMatrixPim);\rleft.bug = screenshot;\r} else {\rtooltipOpacity = raw_process_permalink(webcamFontUser, -1);\rexecutable_router += tape;\r}\rif (tft) {\rbandwidthWeb *= social_page;\r} else {\rregular += 611883;\rthumbnail /= system_lag_keyboard;\r}\rCaesorum illa tu sentit micat vestes papyriferi\r#\rInde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"}]