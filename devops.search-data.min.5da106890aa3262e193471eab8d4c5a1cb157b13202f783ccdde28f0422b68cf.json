[{"id":0,"href":"/devops/docs/CICD/git00/","title":"0. Git이란?","section":"CI/CD 배포 입문","content":" GIT # Git이란? # 깃(Git)은 2005년에 리누스 토르발스에 의해 개발된 분산 버전관리 시스템(Distributed Version Control Systems - DVCS)\n컴퓨터 파일의 변경사항을 추적하고 여러명의 사용자들 간에 파일에 대한 작업을 조율하는데 사용하는 형상관리 도구 이다.\nDVCS에서의 클라이언트는 단순히 파일의 마지막 스냅샷을 Checkout 하지 않고, 저장소를 히스토리와 더불어 전부 복제하여, 서버에 문제가 생기더라도 바로 복구가 가능하다.\nGIT과 SVN의 차이 # 단, Git은 기존 SVN(Subversion SVN)와 기능면에서는 유사해 보일 수는 있으나, 아래와 같은 차이를 가지고 있다.\n기능 SVN GIT 파일관리 중앙서버 업로드 로컬저장소 저장 후, 중앙서버 업로드 형상관리 동시 업로드 시 충돌가능 Branch, Merge로 충돌가능성이 낮음 작업관리 모든 작업이 서버에서 진행 작업은 로컬에서 진행 후, 업로드만 서버에 진행 형상관리 히스토리 관리 기능이 부족 히스토리 관리가 용이하게 구현되어있음 즉, Git과 SVN의 가장 큰 차이는 SVN은 서버단에서 작업을 수행하지만, GIT 로컬에서 자기만의 레포지터리를 생성 및, 분기를 이용한 효율적인 형상관리가 가능하다.\n대부분의 버전관리는 시간순으로 진행되나, GIT은 Branch를 통해 관리한다.\nGit은 대부분의 명령을 local에서 진행하기 때문에, 네트워크 등의 영향을 받지 않고, 무결성을 유지함에 보다 용이하다.\n# GIT Status # Git의 상태에는 크게 3가지가 있다. Committed란 데이터가 로컬 데이터베이스에 안전하게 저장됐다는 것을 의미 Modified는 수정한 파일을 아직 로컬 데이터베이스에 커밋하지 않은 상태 Staged란 현재 수정한 파일을 곧 커밋할 것이라고 표시한 상태 위는 Git의 워킹 트리를 나타내며, Git 디렉토리는 Git이 프로젝트의 메타데이터와 객체 데이터베이스를 저장하는 곳을 의미한다.\n워킹트리는 프로젝트의 특정 버전을 Checkout한 것이며, Git 디렉토리는 현재 작업하는 디스크에 존재하고, 디렉토리 안에 압축된 데이터베이스에서 파일을 가져와 워킹 트리를 생성한다.\nGit에서 Staging Area는 Index라고도 하며, Staging Area는 단순한 파일로, commit할 파일들에 대한 정보를 저장한다.\n즉, Git의 기본적으로 Git의 구동동작은 아래와 같다.\n워킹트리에서 파일을 수정 Staging Area에 파일을 Stage 해서 commit할 스냅샷을 만든다. 여기서 추가, 수정, 삭제 등의 작업이 가능하다. Staging Area에 있는 파일들을 commit해서 Git 디렉토리에 영구적인 스냅샷을 저장한다. 결과적으로 Git 디렉토리에 있는 파일들은 Committed 된 상태이며, 파일을 수정하고 Staging Area에 추가했다면 Staged 된 상태라고 할 수 있다.\n여기서 Checkout 후, 수정했지만 Staging Area에 추가되지 않았다면 Modified된 상태이다.\nGit 설정 # Git 최초 설정 # Git을 설치하고 나면 Git의 사용 환경을 적합하게 설정해주어야 한다.\n이는 git config 라는 도구와 설정으로 내용을 확인하고 변경할 수 있다.\n/etc/gitconfig : 시스템의 모든 사용자와 모든 저장소에 적용되는 설정 ( git config \u0026ndash;system ) ~/.gitconfig, ~/.config/git/config : 특정 사용자에게만 적용되는 설정 ( git config \u0026ndash;global ) .git/config : 현재 디렉토리에만 적용되어 있는 설정 ( git config \u0026ndash;local ) 위 설정들은 역순으로 우선시 되어 1 \u0026lt; 2 \u0026lt; 3 과 같은 우선순위를 가지고 있다.\n$ git config --global user.name \u0026#34;John Doe\u0026#34; $ git config --global user.email johndoe@example.com \u0026ndash;global 옵션으로 설정하는 것은 한번이며 (전역), 만약 프로젝트마다 다른 이름과 메일주소를 사용하고 싶다면 \u0026ndash;global 옵션을 빼고 사용한다. # $ git config --list user.name=John Doe user.email=johndoe@example.com color.status=auto color.branch=auto color.interactive=auto color.diff=auto $ git config user.name john Doe 설정했던 옵션들은 git config \u0026ndash;list 명령어로 확인할 수 있다. # Git의 기초 # $ cd $ git init 위 명령어를 통해 .git이라는 하위 디렉터리를 만들며, 이 안에는 저장소에 필요한 뼈대 파일(Skeleton)이 들어 있다. # $ git add *.c $ git add LICENSE $ git commit -m \u0026#39;initial project version\u0026#39; 위 명령어를 통해 GIt 저장소가 생성되었고 파일 버전 관리가 시작되었다. (commit) # $ git clone https://github.com/libgit2/libgit2 $ git clone https://github.com/libgit2/libgit2 \u0026lt;other name\u0026gt; 다른 프로젝트의 참여하고 싶거나, git 저장소를 복사하고 싶을 때, git clone 명령어를 사용한다. Subversion과 같은 VCS에 익숙한 사용자에게는 \u0026ldquo;Checkout\u0026rdquo; 이 아닌, \u0026ldquo;clone\u0026rdquo; 이라는 점이 다르며, git은 서버에 있는 거의 모든 데이터를 복사한다. 즉, git은 서버의 모든 데이터 및 프로젝트의 히스토리를 전부 받아와, 실제 서버의 디스크가 망가져도, 로컬에서 복구가 가능한 특징을 가진다. (단, 서버설정파일은 제외) # 이제 git 저장소를 만들고(init) 워킹 디렉토리에 Checkout(commit)도 헀다면, 이제는 파일의 스냅샷을 커밋한다. 워킹 디렉토리의 파일은 크게 Tracked(관리대상)과 Untracked(비관리대상)으로 나뉘며, Tracked 파일은 이미 스냅샷에 포함돼 있던 파일(레포지터리에 있던)이다. Tracked 파일은 다시 Unmodified(비수정)와 Modified(수정된), 그리고 Staged(commit으로 저장소에 기록될) 상태로 나뉘어진다. 이 외의 나머지는 untracked파일이며, 이는 워킹 디렉토리에 있는 파일 중 StagingArea에 포함되지 않는 파일이다. 처음 clone을 진행하면, 모든 파일은 Tracked(스냅샷에 포함)파일이지만, Unmodified(수정되지 않았기에)상태이다. 만약 clone 진행 후, 어떤 파일을 수정하게 되면 unmodified -\u0026gt; modified 상태로 상태가 변경되며 실제로 commit을 진행하기 위한 staged 상태를 만들고, staged 상태의 파일을 commit하게 되며, git은 이러한 lifecycle을 반복하게 된다. # $ git status On branch master Your branch is up-to-date with \u0026#39;origin/master\u0026#39;. nothing to commit, working directory clean 위 명령어를 실행하면 현재 하나도 수정되지 않았음을 알려준다. $ echo \u0026#39;My Project\u0026#39; \u0026gt; README $ git status On branch master Your branch is up-to-date with \u0026#39;origin/master\u0026#39;. Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) README nothing added to commit but untracked files present (use \u0026#34;git add\u0026#34; to track) README 파일은 “Untracked”에 속해 있는데 이것은 README 파일이 Untracked 상태라는 것을 의미한다. Git은 Untracked 파일을 아직 스냅샷(커밋)에 넣어지지 않은 파일이라고 본다. git init 명령을 실행한 후, git add (files) 명령을 실행했던 걸 기억할 것이다. 이 명령을 통해 디렉토리에 있는 파일을 추적하고 관리하도록 한다. git add 명령은 파일 또는 디렉토리의 경로를 아규먼트로 받는다. # $ git add README $ git status On branch master Your branch is up-to-date with \u0026#39;origin/master\u0026#39;. Changes to be committed: (use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage) new file: README Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in workingdirectory) modified: CONTRIBUTING.md git status 명령을 실행하면 README 파일이 Tracked 상태이면서 commit에 추가될 Staged 상태라는 것이 확인이 가능하다. \u0026ldquo;Changes to be commiteed\u0026rdquo; 에 들어 있는 파일은 Staged 상태라는 것을 의미한다. 즉, commit을 실행하면 add를 실행한 시점의 파일이 commit되어 stage -\u0026gt; git history에 남게된다. CONTRIBUTING.md은 \u0026ldquo;Changes not staged for commit\u0026quot;에 있으며, 이는 수정한 파일이 Tracked 상태이지만 아직 Staged 상태는 아니라는 것이며 이는 add 명령어를 통해 staged에 올릴 수 있음을 의미한다. # $ git add CONTRIBUTING.md $ git status On branch master Your branch is up-to-date with \u0026#39;origin/master\u0026#39;. Changes to be committed: (use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage) new file: README modified: CONTRIBUTING.md add 후 다시 staus를 입력하면 staged 상태로 올라간 것을 확인할 수 있다. # $ git status -s M README MM Rakefile A lib/git.rb M lib/simplegit.rb ?? LICENSE.txt # 이는 위처럼 status -s 옵션을 통해 간단하게 확인할 수 있으며 앞에 문자는 아래와 같은 의미를 가진다. A : New file M : Modified file MM : 작업 디렉터리 및 스테이지 변경 ?? : Untracked Unmodified 파일을 출력되지 않음 # 파일무시하기 # $ cat .gitignore *.[oa] *~ .gitignore 파일을 만들고 그 안에 무시할 패턴을 적으면, 해당 패턴과 일치하는 파일들은 commit 되지 않는다. .gitignore은 아래와 같은 특징을 가진다. 아무것도 없는 라인이나, #로 시작하는 라인은 무시한다. 표준 Glob 패턴을 사용한다. 이는 프로젝트 전체에 적용된다. 슬래시(/)로 시작하면 하위 디렉토리에 적용되지(Recursivity) 않는다. 디렉토리는 슬래시(/)를 끝에 사용하는 것으로 표현한다. 느낌표(!)로 시작하는 패턴의 파일은 무시하지 않는다 기타 예제는 (gitignore_repo)[https://github.com/github/gitignore]를 참조하자. # 변경사항 확인하기 # $ git diff $ git diff --staged git status 명령은 특정파일의 Staged 상태인지는 확인할 수 있으나, 변경사항은 확인할 수 없다. git diff 명령을 사용하는데 Patch처럼 어떤 라인을 추가했고 삭제했는지가 궁금할 때 사용한다. # $ git log commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test commit a11bef06a3f659402fe7563abf99ad00de2209e6 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Sat Mar 15 10:31:28 2008 -0700 first commit $ git log -p -2 commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number diff --git a/Rakefile b/Rakefile ... $ git log --stat commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number Rakefile | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 ... git log 명령을 실행하면 저장소의 커밋 히스토리를 시간순으로 보여준다. 즉, 가장 최근의 커밋이 가장 먼저 나온다. 그리고 이어서 각 커밋의 SHA-1 체크섬, 저자 이름, 저자 이메일, 커밋한 날짜, 커밋 메시지를 보여준다. -p, \u0026ndash;patch 는 굉장히 유용한 옵션이다. -p 는 각 커밋의 diff 결과를 보여준다. \u0026ndash;stat 옵션으로 각 커밋의 통계 정보를 출력할 수 있다. \u0026ndash;pretty 옵션이다. 이 옵션을 통해 히스토리 내용을 보여줄 때 기본 형식 이외에 여러 가지 중에 하나를 선택할 수 있다. # 회귀 # # $ git commit -m \u0026#39;initial commit\u0026#39; $ git add forgotten_file $ git commit --amend 위는 실수로 파일을 Stage 하는 것을 깜빡하고 빠트린 파일이 있으면 위와 같이 고칠 수 있다. 하지만, 이는 두 번째 commit이 첫 번째 commit이 완전히 뒤집어 쓰는 것(첫 번째 commit은 히스토리가 없어진다)으로 주의가 필요하다. # $ git reset HEAD CONTRIBUTING.md Unstaged changes after reset: M CONTRIBUTING.md $ git status On branch master Changes to be committed: (use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage) renamed: README.md -\u0026gt; README Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: CONTRIBUTING.md $ git status Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: CONTRIBUTING.md $ git checkout -- CONTRIBUTING.md $ git status On branch master Changes to be committed: (use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage) renamed: README.md -\u0026gt; README reset과 staged는 비슷하게 보일 수 있으나, 서로 사용되는 영역이 다른다. reset은 staged영역을 조절하는 데 사용되며, checkout은 주로 브런치 간 이동이나 특정 파일의 변경 내용을 취소하는 데 사용된다. # 리모트 저장소 # # $ git remote -v origin https://github.com/schacon/ticgit (fetch) origin https://github.com/schacon/ticgit (push) remote는 연결되어 있는 저장소를 의미하며, 이는 단지 네트워크 뿐이 아닌 다른 저장소도 의미함을 인지한다. 위 명령어를 통해 현재 연결되어 있는 저장소를 출력할 수 있다. # $ git remote origin $ git remote add pb https://github.com/paulboone/ticgit $ git remote -v origin https://github.com/schacon/ticgit (fetch) origin https://github.com/schacon/ticgit (push) pb https://github.com/paulboone/ticgit (fetch) pb https://github.com/paulboone/ticgit (push) git remote add \u0026lt;단축이름\u0026gt; 으로 원격 저장소를 연격할 수 있다. "},{"id":1,"href":"/devops/docs/Git/git00/","title":"0. Git이란?","section":"Git","content":" GIT # Git이란? # 깃(Git)은 2005년에 리누스 토르발스에 의해 개발된 분산 버전관리 시스템(Distributed Version Control Systems - DVCS)\n컴퓨터 파일의 변경사항을 추적하고 여러명의 사용자들 간에 파일에 대한 작업을 조율하는데 사용하는 형상관리 도구 이다.\nDVCS에서의 클라이언트는 단순히 파일의 마지막 스냅샷을 Checkout 하지 않고, 저장소를 히스토리와 더불어 전부 복제하여, 서버에 문제가 생기더라도 바로 복구가 가능하다.\nGIT과 SVN의 차이 # 단, Git은 기존 SVN(Subversion SVN)와 기능면에서는 유사해 보일 수는 있으나, 아래와 같은 차이를 가지고 있다.\n기능 SVN GIT 파일관리 중앙서버 업로드 로컬저장소 저장 후, 중앙서버 업로드 형상관리 동시 업로드 시 충돌가능 Branch, Merge로 충돌가능성이 낮음 작업관리 모든 작업이 서버에서 진행 작업은 로컬에서 진행 후, 업로드만 서버에 진행 형상관리 히스토리 관리 기능이 부족 히스토리 관리가 용이하게 구현되어있음 즉, Git과 SVN의 가장 큰 차이는 SVN은 서버단에서 작업을 수행하지만, GIT 로컬에서 자기만의 레포지터리를 생성 및, 분기를 이용한 효율적인 형상관리가 가능하다.\n대부분의 버전관리는 시간순으로 진행되나, GIT은 Branch를 통해 관리한다.\nGit은 대부분의 명령을 local에서 진행하기 때문에, 네트워크 등의 영향을 받지 않고, 무결성을 유지함에 보다 용이하다.\n# GIT Status # Git의 상태에는 크게 3가지가 있다. Committed란 데이터가 로컬 데이터베이스에 안전하게 저장됐다는 것을 의미 Modified는 수정한 파일을 아직 로컬 데이터베이스에 커밋하지 않은 상태 Staged란 현재 수정한 파일을 곧 커밋할 것이라고 표시한 상태 위는 Git의 워킹 트리를 나타내며, Git 디렉토리는 Git이 프로젝트의 메타데이터와 객체 데이터베이스를 저장하는 곳을 의미한다.\n워킹트리는 프로젝트의 특정 버전을 Checkout한 것이며, Git 디렉토리는 현재 작업하는 디스크에 존재하고, 디렉토리 안에 압축된 데이터베이스에서 파일을 가져와 워킹 트리를 생성한다.\nGit에서 Staging Area는 Index라고도 하며, Staging Area는 단순한 파일로, commit할 파일들에 대한 정보를 저장한다.\n즉, Git의 기본적으로 Git의 구동동작은 아래와 같다.\n워킹트리에서 파일을 수정 Staging Area에 파일을 Stage 해서 commit할 스냅샷을 만든다. 여기서 추가, 수정, 삭제 등의 작업이 가능하다. Staging Area에 있는 파일들을 commit해서 Git 디렉토리에 영구적인 스냅샷을 저장한다. 결과적으로 Git 디렉토리에 있는 파일들은 Committed 된 상태이며, 파일을 수정하고 Staging Area에 추가했다면 Staged 된 상태라고 할 수 있다.\n여기서 Checkout 후, 수정했지만 Staging Area에 추가되지 않았다면 Modified된 상태이다.\nGit 설정 # Git 최초 설정 # Git을 설치하고 나면 Git의 사용 환경을 적합하게 설정해주어야 한다.\n이는 git config 라는 도구와 설정으로 내용을 확인하고 변경할 수 있다.\n/etc/gitconfig : 시스템의 모든 사용자와 모든 저장소에 적용되는 설정 ( git config \u0026ndash;system ) ~/.gitconfig, ~/.config/git/config : 특정 사용자에게만 적용되는 설정 ( git config \u0026ndash;global ) .git/config : 현재 디렉토리에만 적용되어 있는 설정 ( git config \u0026ndash;local ) 위 설정들은 역순으로 우선시 되어 1 \u0026lt; 2 \u0026lt; 3 과 같은 우선순위를 가지고 있다.\n$ git config --global user.name \u0026#34;John Doe\u0026#34; $ git config --global user.email johndoe@example.com \u0026ndash;global 옵션으로 설정하는 것은 한번이며 (전역), 만약 프로젝트마다 다른 이름과 메일주소를 사용하고 싶다면 \u0026ndash;global 옵션을 빼고 사용한다. # $ git config --list user.name=John Doe user.email=johndoe@example.com color.status=auto color.branch=auto color.interactive=auto color.diff=auto $ git config user.name john Doe 설정했던 옵션들은 git config \u0026ndash;list 명령어로 확인할 수 있다. # Git의 기초 # $ cd $ git init 위 명령어를 통해 .git이라는 하위 디렉터리를 만들며, 이 안에는 저장소에 필요한 뼈대 파일(Skeleton)이 들어 있다. # $ git add *.c $ git add LICENSE $ git commit -m \u0026#39;initial project version\u0026#39; 위 명령어를 통해 GIt 저장소가 생성되었고 파일 버전 관리가 시작되었다. (commit) # $ git clone https://github.com/libgit2/libgit2 $ git clone https://github.com/libgit2/libgit2 \u0026lt;other name\u0026gt; 다른 프로젝트의 참여하고 싶거나, git 저장소를 복사하고 싶을 때, git clone 명령어를 사용한다. Subversion과 같은 VCS에 익숙한 사용자에게는 \u0026ldquo;Checkout\u0026rdquo; 이 아닌, \u0026ldquo;clone\u0026rdquo; 이라는 점이 다르며, git은 서버에 있는 거의 모든 데이터를 복사한다. 즉, git은 서버의 모든 데이터 및 프로젝트의 히스토리를 전부 받아와, 실제 서버의 디스크가 망가져도, 로컬에서 복구가 가능한 특징을 가진다. (단, 서버설정파일은 제외) # 이제 git 저장소를 만들고(init) 워킹 디렉토리에 Checkout(commit)도 헀다면, 이제는 파일의 스냅샷을 커밋한다. 워킹 디렉토리의 파일은 크게 Tracked(관리대상)과 Untracked(비관리대상)으로 나뉘며, Tracked 파일은 이미 스냅샷에 포함돼 있던 파일(레포지터리에 있던)이다. Tracked 파일은 다시 Unmodified(비수정)와 Modified(수정된), 그리고 Staged(commit으로 저장소에 기록될) 상태로 나뉘어진다. 이 외의 나머지는 untracked파일이며, 이는 워킹 디렉토리에 있는 파일 중 StagingArea에 포함되지 않는 파일이다. 처음 clone을 진행하면, 모든 파일은 Tracked(스냅샷에 포함)파일이지만, Unmodified(수정되지 않았기에)상태이다. 만약 clone 진행 후, 어떤 파일을 수정하게 되면 unmodified -\u0026gt; modified 상태로 상태가 변경되며 실제로 commit을 진행하기 위한 staged 상태를 만들고, staged 상태의 파일을 commit하게 되며, git은 이러한 lifecycle을 반복하게 된다. # $ git status On branch master Your branch is up-to-date with \u0026#39;origin/master\u0026#39;. nothing to commit, working directory clean 위 명령어를 실행하면 현재 하나도 수정되지 않았음을 알려준다. $ echo \u0026#39;My Project\u0026#39; \u0026gt; README $ git status On branch master Your branch is up-to-date with \u0026#39;origin/master\u0026#39;. Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) README nothing added to commit but untracked files present (use \u0026#34;git add\u0026#34; to track) README 파일은 “Untracked”에 속해 있는데 이것은 README 파일이 Untracked 상태라는 것을 의미한다. Git은 Untracked 파일을 아직 스냅샷(커밋)에 넣어지지 않은 파일이라고 본다. git init 명령을 실행한 후, git add (files) 명령을 실행했던 걸 기억할 것이다. 이 명령을 통해 디렉토리에 있는 파일을 추적하고 관리하도록 한다. git add 명령은 파일 또는 디렉토리의 경로를 아규먼트로 받는다. # $ git add README $ git status On branch master Your branch is up-to-date with \u0026#39;origin/master\u0026#39;. Changes to be committed: (use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage) new file: README Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in workingdirectory) modified: CONTRIBUTING.md git status 명령을 실행하면 README 파일이 Tracked 상태이면서 commit에 추가될 Staged 상태라는 것이 확인이 가능하다. \u0026ldquo;Changes to be commiteed\u0026rdquo; 에 들어 있는 파일은 Staged 상태라는 것을 의미한다. 즉, commit을 실행하면 add를 실행한 시점의 파일이 commit되어 stage -\u0026gt; git history에 남게된다. CONTRIBUTING.md은 \u0026ldquo;Changes not staged for commit\u0026quot;에 있으며, 이는 수정한 파일이 Tracked 상태이지만 아직 Staged 상태는 아니라는 것이며 이는 add 명령어를 통해 staged에 올릴 수 있음을 의미한다. # $ git add CONTRIBUTING.md $ git status On branch master Your branch is up-to-date with \u0026#39;origin/master\u0026#39;. Changes to be committed: (use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage) new file: README modified: CONTRIBUTING.md add 후 다시 staus를 입력하면 staged 상태로 올라간 것을 확인할 수 있다. # $ git status -s M README MM Rakefile A lib/git.rb M lib/simplegit.rb ?? LICENSE.txt # 이는 위처럼 status -s 옵션을 통해 간단하게 확인할 수 있으며 앞에 문자는 아래와 같은 의미를 가진다. A : New file M : Modified file MM : 작업 디렉터리 및 스테이지 변경 ?? : Untracked Unmodified 파일을 출력되지 않음 # 파일무시하기 # $ cat .gitignore *.[oa] *~ .gitignore 파일을 만들고 그 안에 무시할 패턴을 적으면, 해당 패턴과 일치하는 파일들은 commit 되지 않는다. .gitignore은 아래와 같은 특징을 가진다. 아무것도 없는 라인이나, #로 시작하는 라인은 무시한다. 표준 Glob 패턴을 사용한다. 이는 프로젝트 전체에 적용된다. 슬래시(/)로 시작하면 하위 디렉토리에 적용되지(Recursivity) 않는다. 디렉토리는 슬래시(/)를 끝에 사용하는 것으로 표현한다. 느낌표(!)로 시작하는 패턴의 파일은 무시하지 않는다 기타 예제는 (gitignore_repo)[https://github.com/github/gitignore]를 참조하자. # 변경사항 확인하기 # $ git diff $ git diff --staged git status 명령은 특정파일의 Staged 상태인지는 확인할 수 있으나, 변경사항은 확인할 수 없다. git diff 명령을 사용하는데 Patch처럼 어떤 라인을 추가했고 삭제했는지가 궁금할 때 사용한다. # $ git log commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test commit a11bef06a3f659402fe7563abf99ad00de2209e6 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Sat Mar 15 10:31:28 2008 -0700 first commit $ git log -p -2 commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number diff --git a/Rakefile b/Rakefile ... $ git log --stat commit ca82a6dff817ec66f44342007202690a93763949 Author: Scott Chacon \u0026lt;schacon@gee-mail.com\u0026gt; Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number Rakefile | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 ... git log 명령을 실행하면 저장소의 커밋 히스토리를 시간순으로 보여준다. 즉, 가장 최근의 커밋이 가장 먼저 나온다. 그리고 이어서 각 커밋의 SHA-1 체크섬, 저자 이름, 저자 이메일, 커밋한 날짜, 커밋 메시지를 보여준다. -p, \u0026ndash;patch 는 굉장히 유용한 옵션이다. -p 는 각 커밋의 diff 결과를 보여준다. \u0026ndash;stat 옵션으로 각 커밋의 통계 정보를 출력할 수 있다. \u0026ndash;pretty 옵션이다. 이 옵션을 통해 히스토리 내용을 보여줄 때 기본 형식 이외에 여러 가지 중에 하나를 선택할 수 있다. # 회귀 # # $ git commit -m \u0026#39;initial commit\u0026#39; $ git add forgotten_file $ git commit --amend 위는 실수로 파일을 Stage 하는 것을 깜빡하고 빠트린 파일이 있으면 위와 같이 고칠 수 있다. 하지만, 이는 두 번째 commit이 첫 번째 commit이 완전히 뒤집어 쓰는 것(첫 번째 commit은 히스토리가 없어진다)으로 주의가 필요하다. # $ git reset HEAD CONTRIBUTING.md Unstaged changes after reset: M CONTRIBUTING.md $ git status On branch master Changes to be committed: (use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage) renamed: README.md -\u0026gt; README Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: CONTRIBUTING.md $ git status Changes not staged for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git checkout -- \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: CONTRIBUTING.md $ git checkout -- CONTRIBUTING.md $ git status On branch master Changes to be committed: (use \u0026#34;git reset HEAD \u0026lt;file\u0026gt;...\u0026#34; to unstage) renamed: README.md -\u0026gt; README reset과 staged는 비슷하게 보일 수 있으나, 서로 사용되는 영역이 다른다. reset은 staged영역을 조절하는 데 사용되며, checkout은 주로 브런치 간 이동이나 특정 파일의 변경 내용을 취소하는 데 사용된다. # 리모트 저장소 # # $ git remote -v origin https://github.com/schacon/ticgit (fetch) origin https://github.com/schacon/ticgit (push) remote는 연결되어 있는 저장소를 의미하며, 이는 단지 네트워크 뿐이 아닌 다른 저장소도 의미함을 인지한다. 위 명령어를 통해 현재 연결되어 있는 저장소를 출력할 수 있다. # $ git remote origin $ git remote add pb https://github.com/paulboone/ticgit $ git remote -v origin https://github.com/schacon/ticgit (fetch) origin https://github.com/schacon/ticgit (push) pb https://github.com/paulboone/ticgit (fetch) pb https://github.com/paulboone/ticgit (push) git remote add \u0026lt;단축이름\u0026gt; 으로 원격 저장소를 연격할 수 있다. "},{"id":2,"href":"/devops/docs/CICD/with-toc/","title":"1. 학습목표","section":"CI/CD 배포 입문","content":" 학습목표 # 클라우드 서비스를 활용하기 위한 기본 지식 학습\n클라우드 서비스에 내 프로젝트를 단순 배포하기 위한 환경을 구축\n클라우드 서비스 내 프로젝트 배포를 간편화\n클라우드 서비스에 환경 구축 없이 프로젝트 배포 ( Elastic Beanstalk )\n클라우드 서비스에 배포 자동화\n클라우드 서비스 무중단 배포\n정적 IP 할당을 위한 NLB 활용\n최종목표\n스프링 부트를 사용한 간단한 프로젝트를 생성 후, 배포 "},{"id":3,"href":"/devops/docs/CICD/","title":"CI/CD 배포 입문","section":"Docs","content":" 책소개 # "},{"id":4,"href":"/devops/docs/%EC%9E%84%EC%8B%9C/CPU/","title":"What is CPU","section":"임시","content":" CPU # CPU란 (Central Processing Unit / main processor)으로 컴퓨터 시스템을 통제하고 프로그램(프로세스)의 연산을 실행하는 핵심적인 컴퓨터의 중앙 제어장치로 사람으로 따지면 뇌의 역할은 하는 내장형 칩을 의미한다.\nCPU는 기계어로 쓰인 명령어를 해석하며 실행하며, 외부의 정보를 입력받아 이를 기억하고, 연산하며 외부로 출력하는 역할을 수행한다.\nCPU는 크게 하기 3가지 구분할 수있다.\n처리할 명령어를 저장하는 프로세서와 레지스터 연산을 담당하는 산술논리연산장치(ALU / 연산장치), 명령어의 해석과 올바른 실행을 위해 CPU를 제어하는 제어장치(Control Unit) # CPU의 구조 # Core : CPU의 Core 즉 CPU의 핵심적인 역할을 수행해내는 중심부 역할을 말하며 이 코어에서 시스템의 모든 연산처리를 수행한다.\nThread : Core는 H/W 적인 관점에서 본 관점이며, Thread는 논리적인 작업 관점에서 처리 단위를 나뉘어 연산처리(HyperThreading)를 수행한다고 할 수 있다.\nClock : Clock은 동작 주파수로 CPU의 속도를 나타내는 단위이며, CPU가 데이터 양에 따라 속도가 달라질 수 있다. 단, 클럭이 높을 수록 발열 및 전력사용이 증가하기에, 최근에는 Multi Core 및 Multi Thread로 일정량의 Clock을 유지시켜 성능 향상을 꾀하고 있다.\nCache Memory : CPU 내부에서 임시로 사용하는 버퍼(Buffer) 메모리 중 하나로, 자주 사용하는 파일 등을 따로 모아두고, 나중에 해당 파일을 다시 실행하면 컴퓨터에서 바로 불러오는 파일을 의미하며, CPU가 하나의 데이터를 처리하는 동안 메인 메모리로부터 다음에 처리할 데이터를 불러와 대기하는 시킬 수 있어, 처리 속도를 높일 수 있다.\n정말 간단하게 요악하자면 Core는 몸통, Thread는 몸통에 달린 팔이라고 할 수 있지만, Thread가 무조건 많다고 좋은 것이 아니며, 대부분 Thread가 높을 수록 Clock이 낮기 때문에 개개인에 맞게 사용하는 것이 옳다고 할 수 있다.\n# CPU 아키텍처 # 커널 및 프로세스 : 유저와 CPU 사이에서 서로의 언어를 해석하고 전달(OS, 프로그램)\nProtection ring : 유저가 사용하는 커널과 시스템이 사용하는 커널을 나눔으로써 시스템 자체를 보호(System call)\nVirtaul memroy / Page table : 유저가 사용하는 프로세스가 메모리에 접근하기 전에 사용되는 공간으로 실제 메모리 사용량의 변동성을 억제시켜 이를 통해 시스템의 안전성을 향상시키는 역할을 수행\nContext Switching : 실제 CPU는 특정 프로세스만을 지속적으로 점유시키고 있지 않으며, 다른 프로세스를 스왑하면서 사용되는 데, 이를 Context Switching이라 한다.\nPage Table Entry의 Protechtion bit : 유저가 사용하는 프로세스의 가상 메모리의 특정 주소는 커널 데이터를 담고 있어, sysc all을 호출하여 커널의 도움을 받으러 갈 때 Page Table을 커널 것으로 교체할 필요가 없어져, 파일의 Read/Write\n명령어(instrcution) : CPU 명령어 수행 동작\nPipeline : 파이프라인은 CPU가 하나의 명령어를 처리하는 과정도 너무 복잡하고 많기 때문에, 이를 잘게 쪼개서 여러 가지 작은 단계로 나누어 처리하는 방식\nCache : 주메모리에서 값을 읽는 동작은 CPU의 명령어 처리 속도에 비하면 한참 느리다. 따라서 이 갭을 줄이기 위해 매우 빠르지만 작은 저장 공간이 CPU에 있는데, 이를 캐시라고 한다.\n분기(Branch) 명령어는 어떤 조건이 맞으면 다음에 실행할 명령어의 위치를 임의로 지정할 수 있게 해준다. 이는 같은 명령어들을 반복해서 실행하거나 조건에 따라 다른 일을 하고 싶을 때 사용하는 매우 기본적인 명령어다.\n비순차적 명령어 처리(OoOE)는 파이프라인의 송출(Issue) → 실행(Execute) → 회신(Writeback) 단계에 한해서 늦게 온 명령어가 일찍 온 명령어를 새치기할 수 있는 기술\nSpeculative execution : 어떤 명령어가 특정 파이프라인 단계에 필요한 정보가 없어서 진행이 막혔을 때, 필요한 정보를 예측해서 높은 확률로 맞힌다면 틀렸을 때의 다소 큰 손해를 넘어서는 이익을 취할 수 있다. 고성능의 CPU는 이러한 예측에 기반한 갖가지 기술들을 적극 활용하고 있다.\n# CPU 처리과정 # CPU의 처리과정을 간단하게 나열하면 아래와 같다.\nFetch: 실행할 명령어들을 가져온다.\nDecode: 이후 처리를 돕기 위해 명령어의 종류를 선택 및 결정한다. / CISC, RISC\nRename: 명령어가 가리키는 레지스터를, 내부에 숨어있는 물리적 레지스터로 매핑한다.\nDispatch: 명령어가 실행하기 위해 기다리는 대기열에 넣는다.\nIssue: 대기열에 있는 명령어가 실행될 수 있으면[12] 실행하기 위한 장치로 보낸다.\nExecute: 실행한다.\nWriteback: 결과값을 레지스터에 써야 한다면 쓴다. 결과값을 기다리고 있던 명령어가 있다면 결과가 생겼다고 알려준다.\nCommit: 명령어 수행을 완료하고, 명령어 실행을 위해 할당받은 자원을 모두 토해낸다. 명령어의 실행 결과를 사용자에게 노출시킨다.\n# "},{"id":5,"href":"/devops/docs/%EC%9E%84%EC%8B%9C/DISK/","title":"What is Disk","section":"임시","content":" Disk # # Disk란 보조기억장치로 RAM(주기억장치)이 전원이 없어지면 데이터가 삭제되는 반면, Disk는 전원이 없어진 이후에도 데이터가 유지되는 비휘발성 메모리이다. # HDD # # HDD (Hard Disk drive) 하드 디스크는 플로피 디스크와 같은 자기 기록 매체이나, 플로피 디스크와 다르게 금속 재질의 플래터에 데이터를 기록하기 때문에 플로피디스크와 구분짓기 위해 재질적으로 단단하다는 뜻으로 하드디스크라 한다. # HDD의 원리와 구조 # # 저장되는 모든 데이터는 원리적으로 0 or 1 두 디지털 신호로 의해 이루어진다. # "},{"id":6,"href":"/devops/docs/%EC%9E%84%EC%8B%9C/board/","title":"What is M/B","section":"임시","content":" Main Board # main board란 서버의 주요 구성 부품(CPU, Ram, GPU, Nic 등)들을 설치, 연결, 조절하는 주 회로 기판(main circuit board)을 메인보드(main board)라고 한다.\n각 부품들이 하나로 연결되어 온전한 기능을 할 수 있게 해주는 회로가 존재하는 데, 이 회로들을 통해서 전기를 각 부품에게 배분해주는 역할을 하는 부품이 메인보드이다.\nmain board가 없으면 cpu가 램으로 처리된 정보를 보낼 수 없다.\n메인보드의 ROM에는 bios라는 일종의 작은 운영체제가 들어있다.\n연결된 모든 장치는 메인보드의 bus를 통하여 정보를 교류하며 그 흐름을 메인보드가 관리한다.\n전원공급장치(PSU)에서 공급된 전기는 메인보드에서 다시 전압을 조절하여 프로세서와 메인보드 및 각종 전자 장치에 공급됨\n메인보드에는 ram을 꽂을 수 있는 ram slot과 cpu slot, 내장 사운드 카드와 내장 랜카드, 외장 그래픽 카드, 사운드 카드, tv 수신 카드 등을 꽂을 수 있는 pci 슬롯을 제공함\n즉, main board란 각 파트의 브릿지 역할을 하는 토대이다.\n# Main board Part # # PSU (Power Supply Unit) : 전원공급장치\nNIC (Network Interface Controller) : 외장 네트워크 인터페이스 카드 / IPMI는 내장\nPCI (Peripheral Component Interconnect Bus) : GPU, M.2 등 다른 파트를 장착하기 위한 slot\nCPU : 중앙 처리장치\nMemory : 메인 메모리로 주로 RAM(Random Access Memory)를 의미\nR/C (Raid Controller) : R/C는 각 Disk의 raid 정보를 가지고 있으며, 이를 관리하는 파트\nFAN : 전방에서 후방으로 공기를 순환시키는 선풍기\nDisk : 비휘발성 메모리로 데이터를 저장\nCase : 내부의 파트를 보호하기 위한 Case\n# Memory slot은 하기 사진과 같이 채널을 이루고 있다. "},{"id":7,"href":"/devops/docs/%EC%9E%84%EC%8B%9C/NIC/","title":"What is NIC","section":"임시","content":" Network Interface Card # NIC(Network Interface Controller)이란 서버가 네트워크에 연결하여 통신하기 위해 사용하는 하드웨어 장치이다.\nOSI 계층 1(물리 계층)과 계층 2(데이터 링크 계층) 장치를 가지는데, MAC 주소를 사용하여 낮은 수준의 주소 할당 시스템을 제공하고 네트워크 매개체로 물리적인 접근을 가능하게 한다.\n"},{"id":8,"href":"/devops/docs/%EC%9E%84%EC%8B%9C/Memory/","title":"What is RAM","section":"임시","content":" What is RAM # # RAM이란 Random Access Memory로 ROM Read Only Memotry과는 반대로 휘발성 메모리를 의미한다.\nRandom Access라는 말은 어느 위치에든 똑같은 속도로 접근하여 읽고 쓸 수 있음을 의미하며, 사용자가 자유롭게 내용을 읽고 쓰고 지울 수 있는 기억장치로, 컴퓨터가 켜지면 CPU는 연산 및 동작에 필요한 내용이 전원이 유지되는 동안에 RAM에 저장된다.\n주로 주기억장치로 불리며 보조기억장치로는 흔이 우리가 사용하는 Disk(HDD, SDD 등)가 있다.\n단, RAM의 범주에는 \u0026lsquo;임의 접근\u0026rsquo;할 수 있는 메모리이므로 HDD 등의 장치들도 RAM의 범주에 들어가기도 하지만, HDD 등의 기억장치와 같이 어느 위치에나 직접 접근할 수 있으나 데이터의 물리적 위치에 따라 읽고 쓰는 시간에 차이가 발생하게 되는 기억장치들은 Direct Access Memory 또는 Direct Access Data Storage라고 부른다.\n# 휘발성과 비휘발성 # # 휘발성 메모리 SRAM (Static Random Access Memory) : 전원이 차단되자마자 즉시 데이터가 삭제되는 메모리 DRAM (Dynamic Random Access Memory) : 내부에 전류를 일시적으로 저장하는 역할을 하여 약 5분 정도 데이터가 유지 될 수 있는 메모리 # 메모리 구조 # # 프로그램이 실행되기 위해서는 프로그램이 메모리에 로드(load)되어야 하며, 이에따라 변수들이 저장될 메모리가 필요하다. 즉, 위 사진과 같이 프로그램의 실행을 위해 Code, Data, Heap, Stack 영역을 할당 받을 수 있다. # Code 영역 실행할 프로그램의 코드가 저장되는 영역으로 텍스트(code) 영역이라고도 부른다. 상수 및 컴파일 될 기계어가 들어가며, 프로그램이 시작하고 종료될 때까지 메모리를 점유한다. CPU에서는 Code 영역에 저장된 명령어를 순차적으로 가져가 처리한다. # Data 영역 프로그램의 전역 변수와 정적(Static) 변수가 저장되는 영역으로 Data 영역 또한 프로그램이 시작하고 종료될 때까지 메모리를 점유한다. # Heap 영역 사용자가 직접 관리할 수 있는 영역으로, 사용자에 의해 동적으로 메모리 공간이 할당되고 해제된다. (malloc() 또는 new 연산자를 통해 할당 / free() 또는 delete 연산자를 통해서 해제) 메모리의 낮은 주소에서 높은 주소의 방향으로 할당되며, 런타임 시에 크기가 결정된다. 프로그램에 필요한 개체의 개수나 크기를 미리 알 수 없는 경우 사용 가능 # Stack 영역 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역으로, 함수의 호출과 함께 할당되며 함수의 호출이 완료되면 소멸한다. 함수의 호출 정보를 스택 프레임(Stack frame)이라고 한다. 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다. # "},{"id":9,"href":"/devops/docs/%EC%9E%84%EC%8B%9C/RC/","title":"What is RC","section":"임시","content":" RaidController # R/C(Raid Controller)란 RAID 인프라에서 디스크 드라이브를 관리하는 스토리지 구성 요소 유형입니다. 즉, RAID 디스크를 관리하는 서버에 물리 디스크 드라이브를 논리 장치로 제공한다. RAID 컨트롤러는 디스크 어레이 컨트롤러를 의미힌다. "},{"id":10,"href":"/devops/docs/CICD/table-of-contents/with-toc/","title":"With ToC","section":"Table of Contents","content":" Caput vino delphine in tamen vias # Cognita laeva illo fracta # Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\nTe at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit Natus quaerere # Pectora et sine mulcere, coniuge dum tincta incurvae. Quis iam; est dextra Peneosque, metuis a verba, primo. Illa sed colloque suis: magno: gramen, aera excutiunt concipit.\nPhrygiae petendo suisque extimuit, super, pars quod audet! Turba negarem. Fuerat attonitus; et dextra retinet sidera ulnas undas instimulat vacuae generis? Agnus dabat et ignotis dextera, sic tibi pacis feriente at mora euhoeque comites hostem vestras Phineus. Vultuque sanguine dominoque metuit risi fama vergit summaque meus clarissimus artesque tinguebat successor nominis cervice caelicolae.\nLimitibus misere sit # Aurea non fata repertis praerupit feruntur simul, meae hosti lentaque citius levibus, cum sede dixit, Phaethon texta. Albentibus summos multifidasque iungitur loquendi an pectore, mihi ursaque omnia adfata, aeno parvumque in animi perlucentes. Epytus agis ait vixque clamat ornum adversam spondet, quid sceptra ipsum est. Reseret nec; saeva suo passu debentia linguam terga et aures et cervix de ubera. Coercet gelidumque manus, doluit volvitur induta?\nEnim sua # Iuvenilior filia inlustre templa quidem herbis permittat trahens huic. In cruribus proceres sole crescitque fata, quos quos; merui maris se non tamen in, mea.\nGermana aves pignus tecta # Mortalia rudibusque caelum cognosceret tantum aquis redito felicior texit, nec, aris parvo acre. Me parum contulerant multi tenentem, gratissime suis; vultum tu occupat deficeret corpora, sonum. E Actaea inplevit Phinea concepit nomenque potest sanguine captam nulla et, in duxisses campis non; mercede. Dicere cur Leucothoen obitum?\nPostibus mittam est nubibus principium pluma, exsecratur facta et. Iunge Mnemonidas pallamque pars; vere restitit alis flumina quae quoque, est ignara infestus Pyrrha. Di ducis terris maculatum At sede praemia manes nullaque!\n"},{"id":11,"href":"/devops/docs/%EC%9E%84%EC%8B%9C/key/","title":"암호화","section":"임시","content":" 암호화의 기술과 역사 # 암호화의 역사 # 시대 기간 특징 종류 고대 고대 - 19세기 말 수동 암호 사용 (단순, 문자 대입하여 암호화) Scytale, Caesar, Vigenere, Beaufort 등 근대 1900 - 1940년대 기계 암호 사용 (복잡한 기계를 이용하여 암호화) Enigma, M-209 등 현대 1950년대 - 현재 샤뇬의 \u0026ldquo;암호학의 수학적 배경\u0026rdquo; 발표 이후 시작, 컴퓨터 암호 사용 (컴퓨터 연산을 이용하여 암호화) DES, SEED, Rijindael, RSA, ECC, KCDSA 등 고대에는 외교, 군사 등의 한정적인 분야의 사용되었으나, 현대에는 인터넷, 전자상거래 등이 발달하면서 전반적인 분야의 대한 보안(암호화)의 기능이 중요시 되기 시작했다. 현대 암호화 기술 # 1. 대칭키 암호화 기술 (비밀키) # 송신자와 수신자간의 데이터가 오갈 때, 암호화 및 복호화를 동일한 Key로 진행하는 방식 즉, 송신자 A가 수신자 B에게 특정 파일을 Q라는 Key를 사용하여 암호화해서 보내면, B는 A가 사용했던 Q라는 key를 사용하여 복호화해야만 받은 파일의 확인이 가능하다. 대칭키 암호화는 블록, 스트링 암호를 사용하며, 특징은 아래와 같다. 블록암호(DES): Data Encryption Standard의 약자로 1976년 미국가표준국(NIST) 주도하에 설계된 암호화 방식이다. 63비트 단위의 블록 길이로 암호화한다. 블록 중 키의 길이는 58비트 나머지 8비트는 패리티 체크에 사용 블록암호(AES): DES의 해독 방법이 나오면서 DES를 대체하기 위하여 채택된 방식이다. Advanced Encryption Standard의 약자로 1997년부터 진행하여, 2001년 존 대먼과 빈센트 라이언이 개발한 Rijndael의 알고리즘을 기반하여 만들어졌다. 128비트로 DES보다 더 큰 단위의 블록 길이로 암호화한다. 128비트뿐만 아니라 192비트, 256비트 길이로 암호화 가능 스트링암호: 데이터 스트림(흐름)을 순차적으로 처리해가는 암호 알고리즘으로 데이터가 발생하는 즉시 암호화하여 보내는 방식, 1비트, 8비트, 또는 32 비트 등의 단위로 암호화와 복호화를 진행 구분 블록암호 스트링암호 장점 암호 복잡성이 높고, 기밀성이 높고, 해시 함수를 사용하여 암호화한다. 암호화 속도가 빠르며, 비트 단위로 암호화하기 때문에 다음 한 비트의 에러 발생이 다음 비트에 영향을 주지 않는다. 단점 암호화 속도가 느리며, 블록 내부의 한 비트의 에러 발생이 다른 비트에 쉽게 에러 전달된다. 암호화의 확산이 낮기 때문에 암호의 복잡성이 떨어지며, 비트 단위로 암호화가 진행되기 때문에 비트 사이에 삽입 변경 쉬워, 삽입공격에 취약하다 종류 DES, IDES, SEED, RC5, AES LFSR(Shift Register), MUX generator 암호화 단위 블록 비트 주요대상 일반 데이터 전송, 저장 음성, 오디오/비디오 스트리밍 실시간 부적합 적합 2. 비대칭 암호화 기술 (공개키) # 암호화를 위한 키와, 복호화를 위한 키가 다른 암호화 방식을 말한다. RSA(Rivest, Shamir, Adleman), ECC(Elliptic Curve Cryptosystem), NTRU, XTR 등이 존재한다. 비대칭 암호화 기술은 Public, Private Key 기술을 활용하며, 송신자 A가 수신자 B에게 파일을 보낸다면, 먼저 수신자 B의 Public Key를 사용하여 암호화 시킨 후 발송하면, 이 파일은 Private Key가 있는 B만이 복호화하여 파일을 열 수 있는 구조이다. 3. PKI (Public Key Infrastructure, 공개키기반구조) # PKI는 위에서 언급한 공개키 암호화와 전자서명을 사용할 수 있게 구조를 제시해 둔 것이다. 기존 공개키 방식은 해커 C가 A가 B에게 암호화 통신 중간에 끼어들어, B가 A에게 다시 파일을 보낼 때, 자신의 공공키를 제시하는 식의 문제가 생기기 시작했고, 이를 예방하기 위해 PKI라는 개념을 등장시켰다. PKI는 공개키 기반 구조를 가지기 위해 비대칭키 암호화 방식에서 CA라는 개념을 등장 시킨다. PKI 구성요소는 아래와 같다. 인증기관(CA, Certificate Authority): 사용자의 인증서 발급 및 관리 Ex) 한국정보인증(KICA), 금융결제원(yesSign), 한국진흥정보원(Sigate) 등 등록기관(RA, Registration Authority): 신원확인, 고객 데이터 유지 등 인증기관의 입증을 대행하는 등록기관. Ex) 은행, 증권사 디렉토리(Directory): 인증서 및 인증서 취소목록 등 PKI와 관련된 정보를 저장 및 검색하는 장소 인증서(Certificate): 공개키나 공개키의 정보를 포함하는 인증서 Ex) X.509 인증서 4. SSL/TLS # SSL/TLS는 프로토콜로 PKI가 제공하는 공개 키 인프라와 디지털 인증서를 사용해서 Browser와 server 간 통신. 즉 Website 트랜잭션에 보안 및 무결성을 제공하는 기술이다. SSL (Secure Socket Layer): Browser와 Server가 서로 통신할 때 보안 및 무결성을 제공하는 프로토콜 TLS (Transport Layer Security): SSL과 마찬가지로 Browser와 Server가 서로 통신할 때 보안 및 무결성을 제공하는 프로토콜 즉 SSL과 TLS는 동일한 목적을 수행하는 프로토콜이지만 차이점이라면 TLS 프로토콜은 SSL 프로토콜의 업데이트된 상위 버전이라는 것으로, SSL이 표준화 되면서 이름이 TLS로 변경되었다. 4-1. TLS 통신과정 (Handshake과정) # 클라이언트에서 서버로 접속한다. (https://URL) 클라이언트는 랜덤데이터를 만들어 서버에 보낸다. 클라이언트에서 사용 가능한 암호화방식들을 서버에 보낸다. 서버 -\u0026gt; 클라이언트 서버 또한 랜덤데이터를 만들어 클라이언트에 보낸다. 클라이언트가 보낸 암호화방식들 중에 사용할 방식을 선정하여 클라이언트에 보낸다. SSL 인증서도 같이 보낸다. (SSL 인증서에는 사이트의 Public Key, CA, 도메인 정보등이 존재) 5. 실습 # $ brew install mkcert # 인증을 위한 패키지 설치 $ mkcert -install # localhost 인증된 발급기관 추가(localhost용 ca) $ mkcert -key-file key.pem -cert-file cert.pem localhost 127.0.0.1 ::1 # localhost, 127.0.0.1(IPv4), ::1(IPv6)에서 사용할 수 있는 인증서 생성 cert.pem, key.pem이라는 파일이 생성 cert.pem 파일의 경우 공개키와 인증기관의 서명을 포함하고 있는 인증서이며, key.pem의 경우 개인 키 # https.js 파일 생성 후 확인 const https = require(\u0026#39;https\u0026#39;); const fs = require(\u0026#39;fs\u0026#39;); https .createServer( { key: fs.readFileSync(\u0026#39;./key.pem\u0026#39;, \u0026#39;utf-8\u0026#39;), cert: fs.readFileSync(\u0026#39;./cert.pem\u0026#39;, \u0026#39;utf-8\u0026#39;), }, function (req, res) { res.write(\u0026#39;Congrats! You made https server now :)\u0026#39;); res.end(); } ) .listen(443); $ sudo node https.js $ curl localhost:443 Congrats! You made https server now :) https:localhost:443 으로 접속하여도 자물쇠 아이콘을 확인할 수 있음 Reference https://m.blog.naver.com/taeheon714/222278059898 https://byoungsoo.github.io/etc/2022/06/08/pki.html https://swingswing.tistory.com/155 "},{"id":12,"href":"/devops/docs/CICD/table-of-contents/","title":"Table of Contents","section":"CI/CD 배포 입문","content":" Ubi loqui # Mentem genus facietque salire tempus bracchia # Lorem markdownum partu paterno Achillem. Habent amne generosi aderant ad pellem nec erat sustinet merces columque haec et, dixit minus nutrit accipiam subibis subdidit. Temeraria servatum agros qui sed fulva facta. Primum ultima, dedit, suo quisque linguae medentes fixo: tum petis.\nRapit vocant si hunc siste adspice # Ora precari Patraeque Neptunia, dixit Danae Cithaeron armaque maxima in nati Coniugis templis fluidove. Effugit usus nec ingreditur agmen ac manus conlato. Nullis vagis nequiquam vultibus aliquos altera suum venis teneas fretum. Armos remotis hoc sine ferrea iuncta quam!\nLocus fuit caecis # Nefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral), northbridge_services_troubleshooting, personal( firmware_rw.trash_rw_crm.device(interactive_gopher_personal, software, -1), megabit, ergonomicsSoftware(cmyk_usb_panel, mips_whitelist_duplex, cpa))); if (5) { managementNetwork += dma - boolean; kilohertz_token = 2; honeypot_affiliate_ergonomics = fiber; } mouseNorthbridge = byte(nybble_xmp_modem.horse_subnet( analogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet), gateway_ospf), repository.domain_key.mouse(serverData(fileNetwork, trim_duplex_file), cellTapeDirect, token_tooltip_mashup( ripcordingMashup))); module_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) + coreLog.joystick(componentUdpLink), windows_expansion_touchscreen); bashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling( ciscNavigationBacklink, table + cleanDriver), indexProtocolIsp); Placabilis coactis nega ingemuit ignoscat nimia non # Frontis turba. Oculi gravis est Delphice; inque praedaque sanguine manu non.\nif (ad_api) { zif += usb.tiffAvatarRate(subnet, digital_rt) + exploitDrive; gigaflops(2 - bluetooth, edi_asp_memory.gopher(queryCursor, laptop), panel_point_firmware); spyware_bash.statePopApplet = express_netbios_digital( insertion_troubleshooting.brouter(recordFolderUs), 65); } recursionCoreRay = -5; if (hub == non) { portBoxVirus = soundWeb(recursive_card(rwTechnologyLeopard), font_radcab, guidCmsScalable + reciprocalMatrixPim); left.bug = screenshot; } else { tooltipOpacity = raw_process_permalink(webcamFontUser, -1); executable_router += tape; } if (tft) { bandwidthWeb *= social_page; } else { regular += 611883; thumbnail /= system_lag_keyboard; } Caesorum illa tu sentit micat vestes papyriferi # Inde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"}]